/*
 * Copyright (c) SpiderOak, Inc. All rights reserved.
 */
/**
 * @file aranya-client.h
 * @brief External header file containing C function definitions
 * for the Aranya client library.
 */
 

#ifndef ARANYA_CLIENT_H
#define ARANYA_CLIENT_H

#pragma once

/* Code generated by `capi`. DO NOT EDIT. */

#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>
#include <sys/socket.h>

#ifndef __has_attribute
    #define __has_attribute(x) 0
#endif /* __has_attribute */

#if !defined(ARANYA_ALIGNED)
    #if __has_attribute(aligned)
        #define ARANYA_ALIGNED(n) __attribute__((aligned(n)))
    #else
        #error "compiler must support `aligned` attribute"
    #endif
#endif /* ARANYA_ALIGNED */

#if !defined(ARANYA_DESIGNATED_INIT)
    #if __has_attribute(designated_init)
        #define ARANYA_DESIGNATED_INIT __attribute__((designated_init))
    #else
        #define ARANYA_DESIGNATED_INIT
    #endif
#endif /* ARANYA_DESIGNATED_INIT */

#if !defined(ARANYA_MUST_USE)
    #if __has_attribute(warn_unused_result)
        #define ARANYA_MUST_USE __attribute__((warn_unused_result))
    #else
        #define ARANYA_MUST_USE
    #endif
#endif /* ARANYA_MUST_USE */

#if !defined(ARANYA_NO_RETURN)
    #if __has_attribute(noreturn)
        #define ARANYA_NO_RETURN __attribute__((noreturn))
    #else
        #define ARANYA_NO_RETURN
    #endif
#endif /* ARANYA_NO_RETURN */

#if !defined(ARANYA_NON_NULL)
    #if defined(__gnu__)
        #if __has_attribute(nonnull)
            #define ARANYA_NON_NULL __attribute__((nonnull))
        #endif
    #elif defined(__clang__)
        #define ARANYA_NON_NULL _Nonnull
    #else
        #define ARANYA_NON_NULL
    #endif
#endif /* ARANYA_NON_NULL */

#if !defined(ARANYA_PACKED)
    #if __has_attribute(packed)
        #define ARANYA_PACKED __attribute__((packed))
    #else
        #define ARANYA_PACKED
    #endif
#endif /* ARANYA_PACKED */


#define ARANYA_DURATION_SECONDS (1000 * ARANYA_DURATION_MILLISECONDS)

#define ARANYA_DURATION_MILLISECONDS (1000 * ARANYA_DURATION_MICROSECONDS)

#define ARANYA_DURATION_MICROSECONDS (1000 * ARANYA_DURATION_NANOSECONDS)

#define ARANYA_DURATION_NANOSECONDS 1

/**
 * The size in bytes of an ID
 */
#define ARANYA_ID_LEN 32

/**
 * The size in bytes of a PSK seed IKM.
 */
#define ARANYA_SEED_IKM_LEN 32

/**
 * The size in bytes of an ID converted to a human-readable base58 string.
 */
#define ARANYA_ID_STR_LEN (((ARANYA_ID_LEN * 1375) / 1000) + 1)

/**
 * An enum containing all [`AranyaAqcPeerChannel`](@ref AranyaAqcPeerChannel) variants.
 */
enum AranyaAqcChannelType
#ifdef __cplusplus
  : uint8_t
#endif // __cplusplus
 {
    ARANYA_AQC_CHANNEL_TYPE_BIDIRECTIONAL,
    ARANYA_AQC_CHANNEL_TYPE_RECEIVER,
};
#ifndef __cplusplus
typedef uint8_t AranyaAqcChannelType;
#endif // __cplusplus

/**
 * Valid channel operations for a label assignment.
 */
enum AranyaChanOp
#ifdef __cplusplus
  : uint8_t
#endif // __cplusplus
 {
    /**
     * The device can only receive data in channels with this
     * label.
     */
    ARANYA_CHAN_OP_RECV_ONLY,
    /**
     * The device can only send data in channels with this
     * label.
     */
    ARANYA_CHAN_OP_SEND_ONLY,
    /**
     * The device can send and receive data in channels with this
     * label.
     */
    ARANYA_CHAN_OP_SEND_RECV,
};
#ifndef __cplusplus
typedef uint8_t AranyaChanOp;
#endif // __cplusplus

/**
 * An error code.
 *
 * For extended error information, see [`AranyaExtError`](@ref AranyaExtError).
 */
enum AranyaError
#ifdef __cplusplus
  : uint32_t
#endif // __cplusplus
 {
    /**
     * Success.
     */
    ARANYA_ERROR_SUCCESS,
    /**
     * Internal bug discovered.
     */
    ARANYA_ERROR_BUG,
    /**
     * Timed out.
     */
    ARANYA_ERROR_TIMEOUT,
    /**
     * Invalid argument.
     */
    ARANYA_ERROR_INVALID_ARGUMENT,
    /**
     * Buffer is too small.
     */
    ARANYA_ERROR_BUFFER_TOO_SMALL,
    /**
     * Invalid UTF-8.
     */
    ARANYA_ERROR_INVALID_UTF8,
    /**
     * Invalid Address.
     */
    ARANYA_ERROR_INVALID_ADDR,
    /**
     * Could not send request to daemon.
     */
    ARANYA_ERROR_IPC,
    /**
     * An Aranya error.
     */
    ARANYA_ERROR_ARANYA,
    /**
     * AQC library error.
     */
    ARANYA_ERROR_AQC,
    /**
     * Tried to poll an endpoint but nothing received yet.
     */
    ARANYA_ERROR_WOULD_BLOCK,
    /**
     * A connection got unexpectedly closed.
     */
    ARANYA_ERROR_CLOSED,
    /**
     * Unable to create configuration info.
     */
    ARANYA_ERROR_CONFIG,
    /**
     * Serialization error.
     */
    ARANYA_ERROR_SERIALIZATION,
    /**
     * Some other error occurred.
     */
    ARANYA_ERROR_OTHER,
};
#ifndef __cplusplus
typedef uint32_t AranyaError;
#endif // __cplusplus

/**
 * An enum containing team roles defined in the Aranya policy.
 */
enum AranyaRole
#ifdef __cplusplus
  : uint8_t
#endif // __cplusplus
 {
    /**
     * Owner role.
     */
    ARANYA_ROLE_OWNER,
    /**
     * Admin role.
     */
    ARANYA_ROLE_ADMIN,
    /**
     * Operator role.
     */
    ARANYA_ROLE_OPERATOR,
    /**
     * Member role.
     */
    ARANYA_ROLE_MEMBER,
};
#ifndef __cplusplus
typedef uint8_t AranyaRole;
#endif // __cplusplus

/**
 * Extended error information.
 */
typedef struct ARANYA_ALIGNED(8) AranyaExtError {
    /**
     * This field only exists for size purposes. It is
     * UNDEFINED BEHAVIOR to read from or write to it.
     * @private
     */
    uint8_t __for_size_only[88];
} AranyaExtError;

/**
 * A handle to an Aranya Client.
 */
typedef struct ARANYA_ALIGNED(16) AranyaClient {
    /**
     * This field only exists for size purposes. It is
     * UNDEFINED BEHAVIOR to read from or write to it.
     * @private
     */
    uint8_t __for_size_only[3728];
} AranyaClient;

/**
 * Configuration info for Aranya.
 *
 * Use a [`AranyaClientConfigBuilder`](@ref AranyaClientConfigBuilder) to construct this object.
 */
typedef struct ARANYA_ALIGNED(8) AranyaClientConfig {
    /**
     * This field only exists for size purposes. It is
     * UNDEFINED BEHAVIOR to read from or write to it.
     * @private
     */
    uint8_t __for_size_only[56];
} AranyaClientConfig;

/**
 * Cryptographically secure Aranya ID.
 */
typedef struct AranyaId {
    uint8_t bytes[ARANYA_ID_LEN];
} AranyaId;

/**
 * Device ID.
 */
typedef struct AranyaDeviceId {
    struct AranyaId id;
} AranyaDeviceId;

/**
 * Configuration info builder for an Aranya client config [`AranyaClientConfig`](@ref AranyaClientConfig).
 */
typedef struct ARANYA_ALIGNED(8) AranyaClientConfigBuilder {
    /**
     * This field only exists for size purposes. It is
     * UNDEFINED BEHAVIOR to read from or write to it.
     * @private
     */
    uint8_t __for_size_only[72];
} AranyaClientConfigBuilder;

/**
 * Configuration info builder for Aranya QUIC Channels config [`AranyaAqcConfig`](@ref AranyaAqcConfig).
 */
typedef struct ARANYA_ALIGNED(8) AranyaAqcConfigBuilder {
    /**
     * This field only exists for size purposes. It is
     * UNDEFINED BEHAVIOR to read from or write to it.
     * @private
     */
    uint8_t __for_size_only[24];
} AranyaAqcConfigBuilder;

/**
 * Configuration info for Aranya QUIC Channels.
 *
 * Use a [`AranyaAqcConfigBuilder`](@ref AranyaAqcConfigBuilder) to construct this object.
 */
typedef struct ARANYA_ALIGNED(8) AranyaAqcConfig {
    /**
     * This field only exists for size purposes. It is
     * UNDEFINED BEHAVIOR to read from or write to it.
     * @private
     */
    uint8_t __for_size_only[40];
} AranyaAqcConfig;

/**
 * A builder for initializing a [`AranyaQuicSyncConfig`](@ref AranyaQuicSyncConfig).
 *
 * The [`AranyaQuicSyncConfig`](@ref AranyaQuicSyncConfig) is an optional part of initializing a [`AranyaTeamConfig`](@ref AranyaTeamConfig).
 */
typedef struct ARANYA_ALIGNED(8) AranyaQuicSyncConfigBuilder {
    /**
     * This field only exists for size purposes. It is
     * UNDEFINED BEHAVIOR to read from or write to it.
     * @private
     */
    uint8_t __for_size_only[288];
} AranyaQuicSyncConfigBuilder;

/**
 * Raw PSK seed IKM for QUIC syncer.
 */
typedef struct AranyaSeedIkm {
    uint8_t bytes[ARANYA_SEED_IKM_LEN];
} AranyaSeedIkm;

/**
 * QUIC syncer configuration.
 *
 * Use a [`AranyaQuicSyncConfigBuilder`](@ref AranyaQuicSyncConfigBuilder) to construct this object.
 */
typedef struct ARANYA_ALIGNED(8) AranyaQuicSyncConfig {
    /**
     * This field only exists for size purposes. It is
     * UNDEFINED BEHAVIOR to read from or write to it.
     * @private
     */
    uint8_t __for_size_only[288];
} AranyaQuicSyncConfig;

/**
 * A builder for initializing a [`AranyaTeamConfig`](@ref AranyaTeamConfig).
 */
typedef struct ARANYA_ALIGNED(8) AranyaTeamConfigBuilder {
    /**
     * This field only exists for size purposes. It is
     * UNDEFINED BEHAVIOR to read from or write to it.
     * @private
     */
    uint8_t __for_size_only[288];
} AranyaTeamConfigBuilder;

/**
 * Team configuration.
 *
 * Use a [`AranyaTeamConfigBuilder`](@ref AranyaTeamConfigBuilder) to construct this object.
 */
typedef struct ARANYA_ALIGNED(8) AranyaTeamConfig {
    /**
     * This field only exists for size purposes. It is
     * UNDEFINED BEHAVIOR to read from or write to it.
     * @private
     */
    uint8_t __for_size_only[288];
} AranyaTeamConfig;

/**
 * Builder for a Sync Peer config [`AranyaSyncPeerConfig`](@ref AranyaSyncPeerConfig).
 */
typedef struct ARANYA_ALIGNED(8) AranyaSyncPeerConfigBuilder {
    /**
     * This field only exists for size purposes. It is
     * UNDEFINED BEHAVIOR to read from or write to it.
     * @private
     */
    uint8_t __for_size_only[40];
} AranyaSyncPeerConfigBuilder;

/**
 * Sync Peer config.
 *
 * Use a [`AranyaSyncPeerConfigBuilder`](@ref AranyaSyncPeerConfigBuilder) to construct this object.
 */
typedef struct ARANYA_ALIGNED(8) AranyaSyncPeerConfig {
    /**
     * This field only exists for size purposes. It is
     * UNDEFINED BEHAVIOR to read from or write to it.
     * @private
     */
    uint8_t __for_size_only[32];
} AranyaSyncPeerConfig;

/**
 * A type to represent a span of time in nanoseconds.
 */
typedef uint64_t AranyaDuration;

/**
 * Team ID.
 */
typedef struct AranyaTeamId {
    struct AranyaId id;
} AranyaTeamId;

/**
 * An AQC label name.
 *
 * E.g. "TELEMETRY_LABEL"
 */
typedef const char *AranyaLabelName;

/**
 * Label ID.
 */
typedef struct AranyaLabelId {
    struct AranyaId id;
} AranyaLabelId;

/**
 * A network socket address for an Aranya client.
 *
 * E.g. "localhost:8080", "127.0.0.1:8080"
 */
typedef const char *AranyaAddr;

/**
 * A network identifier for an Aranya client.
 *
 * E.g. "localhost:8080", "127.0.0.1:8080"
 */
typedef const char *AranyaNetIdentifier;

/**
 * A type containing the AQC channel variant.
 *
 * Note that this data is only valid after a successful call to
 * `try_receive_channel`, and is invalidated after calling
 * `get_bidi_channel`/`get_receive_channel`.
 */
typedef struct ARANYA_ALIGNED(8) AranyaAqcPeerChannel {
    /**
     * This field only exists for size purposes. It is
     * UNDEFINED BEHAVIOR to read from or write to it.
     * @private
     */
    uint8_t __for_size_only[120];
} AranyaAqcPeerChannel;

/**
 * An AQC Bidirectional Channel Object.
 */
typedef struct ARANYA_ALIGNED(8) AranyaAqcBidiChannel {
    /**
     * This field only exists for size purposes. It is
     * UNDEFINED BEHAVIOR to read from or write to it.
     * @private
     */
    uint8_t __for_size_only[112];
} AranyaAqcBidiChannel;

/**
 * An AQC Sender Channel Object.
 */
typedef struct ARANYA_ALIGNED(8) AranyaAqcSendChannel {
    /**
     * This field only exists for size purposes. It is
     * UNDEFINED BEHAVIOR to read from or write to it.
     * @private
     */
    uint8_t __for_size_only[112];
} AranyaAqcSendChannel;

/**
 * An AQC Receiver Channel Object.
 */
typedef struct ARANYA_ALIGNED(8) AranyaAqcReceiveChannel {
    /**
     * This field only exists for size purposes. It is
     * UNDEFINED BEHAVIOR to read from or write to it.
     * @private
     */
    uint8_t __for_size_only[112];
} AranyaAqcReceiveChannel;

/**
 * An AQC Bidirectional Stream Object.
 */
typedef struct ARANYA_ALIGNED(8) AranyaAqcBidiStream {
    /**
     * This field only exists for size purposes. It is
     * UNDEFINED BEHAVIOR to read from or write to it.
     * @private
     */
    uint8_t __for_size_only[184];
} AranyaAqcBidiStream;

/**
 * An AQC Sender Stream Object.
 */
typedef struct ARANYA_ALIGNED(8) AranyaAqcSendStream {
    /**
     * This field only exists for size purposes. It is
     * UNDEFINED BEHAVIOR to read from or write to it.
     * @private
     */
    uint8_t __for_size_only[152];
} AranyaAqcSendStream;

/**
 * An AQC Receiver Stream Object.
 */
typedef struct ARANYA_ALIGNED(8) AranyaAqcReceiveStream {
    /**
     * This field only exists for size purposes. It is
     * UNDEFINED BEHAVIOR to read from or write to it.
     * @private
     */
    uint8_t __for_size_only[184];
} AranyaAqcReceiveStream;

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

/**
 * Returns a human-readable error message for an [`AranyaError`](@ref AranyaError).
 *
 * The resulting pointer must NOT be freed.
 *
 * @param err `u32` error code from `AranyaError`.
 *
 * @relates AranyaError.
 */
const char *aranya_error_to_str(uint32_t err);

/**
 * Initializes `AranyaExtError`.
 *
 * When no longer needed, `out`'s resources must be released
 * with its cleanup routine.
 *
 * @relates AranyaExtError
 */
AranyaError aranya_ext_error_init(struct AranyaExtError *out);

/**
 * Initializes `AranyaExtError`.
 *
 * When no longer needed, `out`'s resources must be released
 * with its cleanup routine.
 *
 * @relates AranyaExtError
 */
AranyaError aranya_ext_error_init_ext(struct AranyaExtError *out,
                                      struct AranyaExtError *__ext_err);

/**
 * Releases any resources associated with `ptr`.
 *
 * `ptr` must either be null or initialized by `::aranya_ext_error_init`.
 *
 * @relates AranyaExtError
 */
AranyaError aranya_ext_error_cleanup(struct AranyaExtError *ptr);

/**
 * Releases any resources associated with `ptr`.
 *
 * `ptr` must either be null or initialized by `::aranya_ext_error_init`.
 *
 * @relates AranyaExtError
 */
AranyaError aranya_ext_error_cleanup_ext(struct AranyaExtError *ptr,
                                         struct AranyaExtError *__ext_err);

/**
 * Copies the extended error's message into `msg`.
 *
 * If `msg_len` is large enough to fit the entire message,
 * including the trailing null byte, it updates `msg_len`
 * with the length of the message and copies the message
 * into `msg`.
 *
 * Otherwise, if `msg_len` is not large enough to fit the
 * entire message, including the trailing null byte, it
 * updates `msg_len` with the length of the message and
 * returns `::ARANYA_ERROR_BUFFER_TOO_SMALL`.
 *
 * @param err the error to get a message for [`AranyaExtError`](@ref AranyaExtError).
 * @param msg buffer to copy error message into.
 * @param msg_len length of the message buffer.
 *
 * @relates AranyaExtError.
 */
AranyaError aranya_ext_error_msg(const struct AranyaExtError *err,
                                 char *msg,
                                 size_t *msg_len);

/**
 * Copies the extended error's message into `msg`.
 *
 * If `msg_len` is large enough to fit the entire message,
 * including the trailing null byte, it updates `msg_len`
 * with the length of the message and copies the message
 * into `msg`.
 *
 * Otherwise, if `msg_len` is not large enough to fit the
 * entire message, including the trailing null byte, it
 * updates `msg_len` with the length of the message and
 * returns `::ARANYA_ERROR_BUFFER_TOO_SMALL`.
 *
 * @param err the error to get a message for [`AranyaExtError`](@ref AranyaExtError).
 * @param msg buffer to copy error message into.
 * @param msg_len length of the message buffer.
 *
 * @relates AranyaExtError.
 */
AranyaError aranya_ext_error_msg_ext(const struct AranyaExtError *err,
                                     char *msg,
                                     size_t *msg_len,
                                     struct AranyaExtError *__ext_err);

/**
 * Initializes a new client instance.
 *
 * @param client the uninitialized Aranya Client [`AranyaClient`](@ref AranyaClient).
 * @param config the client's configuration [`AranyaClientConfig`](@ref AranyaClientConfig).
 *
 * @relates AranyaClient.
 */
AranyaError aranya_client_init(struct AranyaClient *client,
                               const struct AranyaClientConfig *config);

/**
 * Initializes a new client instance.
 *
 * @param client the uninitialized Aranya Client [`AranyaClient`](@ref AranyaClient).
 * @param config the client's configuration [`AranyaClientConfig`](@ref AranyaClientConfig).
 *
 * @relates AranyaClient.
 */
AranyaError aranya_client_init_ext(struct AranyaClient *client,
                                   const struct AranyaClientConfig *config,
                                   struct AranyaExtError *__ext_err);

/**
 * Releases any resources associated with `ptr`.
 *
 * `ptr` must either be null or initialized by `::aranya_client_init`.
 *
 * @relates AranyaClient
 */
AranyaError aranya_client_cleanup(struct AranyaClient *ptr);

/**
 * Releases any resources associated with `ptr`.
 *
 * `ptr` must either be null or initialized by `::aranya_client_init`.
 *
 * @relates AranyaClient
 */
AranyaError aranya_client_cleanup_ext(struct AranyaClient *ptr,
                                      struct AranyaExtError *__ext_err);

/**
 * Initializes logging.
 *
 * Assumes the `ARANYA_CAPI` environment variable has been set to the desired tracing log level.
 * E.g. `ARANYA_CAPI=debug`.
 */
AranyaError aranya_init_logging(void);

/**
 * Initializes logging.
 *
 * Assumes the `ARANYA_CAPI` environment variable has been set to the desired tracing log level.
 * E.g. `ARANYA_CAPI=debug`.
 */
AranyaError aranya_init_logging_ext(struct AranyaExtError *__ext_err);

/**
 * Decodes the hexadecimal string `src` into `dst` and returns
 * the number of bytes written to `dst`.
 *
 * If `src` is a valid hexadecimal string, the number of bytes
 * written to `dst` will be exactly half the length of `src`.
 * Therefore, `dst` must be at least half as long as `src`.
 *
 * @param dst the output buffer
 * @param src the input hexadecimal string
 */
AranyaError aranya_decode_hex(uint8_t *dst,
                              size_t dst_len,
                              const uint8_t *src,
                              size_t src_len,
                              size_t *__output);

/**
 * Decodes the hexadecimal string `src` into `dst` and returns
 * the number of bytes written to `dst`.
 *
 * If `src` is a valid hexadecimal string, the number of bytes
 * written to `dst` will be exactly half the length of `src`.
 * Therefore, `dst` must be at least half as long as `src`.
 *
 * @param dst the output buffer
 * @param src the input hexadecimal string
 */
AranyaError aranya_decode_hex_ext(uint8_t *dst,
                                  size_t dst_len,
                                  const uint8_t *src,
                                  size_t src_len,
                                  size_t *__output,
                                  struct AranyaExtError *__ext_err);

/**
 * Gets the public key bundle for this device.
 *
 * @param client the Aranya Client [`AranyaClient`](@ref AranyaClient).
 * @param keybundle keybundle byte buffer `KeyBundle`.
 * @param keybundle_len returns the length of the serialized keybundle.
 *
 * @relates AranyaClient.
 */
AranyaError aranya_get_key_bundle(struct AranyaClient *client,
                                  uint8_t *keybundle,
                                  size_t *keybundle_len);

/**
 * Gets the public key bundle for this device.
 *
 * @param client the Aranya Client [`AranyaClient`](@ref AranyaClient).
 * @param keybundle keybundle byte buffer `KeyBundle`.
 * @param keybundle_len returns the length of the serialized keybundle.
 *
 * @relates AranyaClient.
 */
AranyaError aranya_get_key_bundle_ext(struct AranyaClient *client,
                                      uint8_t *keybundle,
                                      size_t *keybundle_len,
                                      struct AranyaExtError *__ext_err);

/**
 * Writes the human-readable encoding of `id` to `str`.
 *
 * To always succeed, `str` must be at least `ARANYA_ID_STR_LEN` bytes long.
 *
 * @param device ID [`AranyaId`](@ref AranyaId).
 * @param str ID string [`AranyaId`](@ref AranyaId).
 * @param str_len returns the length of `str`
 *
 * @relates AranyaId.
 */
AranyaError aranya_id_to_str(const struct AranyaId *id,
                             char *str,
                             size_t *str_len);

/**
 * Decodes `str` into an [`AranyaId`](@ref AranyaId).
 *
 * @param str pointer to a null-terminated string.
 *
 * @relates AranyaId.
 */
AranyaError aranya_id_from_str(const char *str, struct AranyaId *__output);

/**
 * Gets the public device ID.
 *
 * @param client the Aranya Client [`AranyaClient`](@ref AranyaClient).
 * @param __output the client's device ID [`AranyaDeviceId`](@ref AranyaDeviceId).
 *
 * @relates AranyaClient.
 */
AranyaError aranya_get_device_id(struct AranyaClient *client,
                                 struct AranyaDeviceId *__output);

/**
 * Gets the public device ID.
 *
 * @param client the Aranya Client [`AranyaClient`](@ref AranyaClient).
 * @param __output the client's device ID [`AranyaDeviceId`](@ref AranyaDeviceId).
 *
 * @relates AranyaClient.
 */
AranyaError aranya_get_device_id_ext(struct AranyaClient *client,
                                     struct AranyaDeviceId *__output,
                                     struct AranyaExtError *__ext_err);

/**
 * Initializes `AranyaClientConfigBuilder`.
 *
 * When no longer needed, `out`'s resources must be released
 * with its cleanup routine.
 *
 * @relates AranyaClientConfigBuilder
 */
AranyaError aranya_client_config_builder_init(struct AranyaClientConfigBuilder *out);

/**
 * Initializes `AranyaClientConfigBuilder`.
 *
 * When no longer needed, `out`'s resources must be released
 * with its cleanup routine.
 *
 * @relates AranyaClientConfigBuilder
 */
AranyaError aranya_client_config_builder_init_ext(struct AranyaClientConfigBuilder *out,
                                                  struct AranyaExtError *__ext_err);

/**
 * Releases any resources associated with `ptr`.
 *
 * `ptr` must either be null or initialized by `::aranya_client_config_builder_init`.
 *
 * @relates AranyaClientConfigBuilder
 */
AranyaError aranya_client_config_builder_cleanup(struct AranyaClientConfigBuilder *ptr);

/**
 * Releases any resources associated with `ptr`.
 *
 * `ptr` must either be null or initialized by `::aranya_client_config_builder_init`.
 *
 * @relates AranyaClientConfigBuilder
 */
AranyaError aranya_client_config_builder_cleanup_ext(struct AranyaClientConfigBuilder *ptr,
                                                     struct AranyaExtError *__ext_err);

/**
 * Attempts to construct a [`AranyaClientConfig`](@ref AranyaClientConfig).
 *
 * This function consumes and releases any resources associated
 * with the memory pointed to by `cfg`.
 *
 * @param cfg a pointer to the client config builder
 * @param out a pointer to write the client config to
 *
 * @relates AranyaClientConfigBuilder.
 */
AranyaError aranya_client_config_build(struct AranyaClientConfigBuilder *cfg,
                                       struct AranyaClientConfig *out);

/**
 * Attempts to construct a [`AranyaClientConfig`](@ref AranyaClientConfig).
 *
 * This function consumes and releases any resources associated
 * with the memory pointed to by `cfg`.
 *
 * @param cfg a pointer to the client config builder
 * @param out a pointer to write the client config to
 *
 * @relates AranyaClientConfigBuilder.
 */
AranyaError aranya_client_config_build_ext(struct AranyaClientConfigBuilder *cfg,
                                           struct AranyaClientConfig *out,
                                           struct AranyaExtError *__ext_err);

/**
 * Sets Unix Domain Socket path that the daemon is listening on.
 *
 * @param cfg a pointer to the client config builder
 * @param address a string containing the address
 *
 * @relates AranyaClientConfigBuilder.
 */
AranyaError aranya_client_config_builder_set_daemon_uds_path(struct AranyaClientConfigBuilder *cfg,
                                                             const char *address);

/**
 * Sets Unix Domain Socket path that the daemon is listening on.
 *
 * @param cfg a pointer to the client config builder
 * @param address a string containing the address
 *
 * @relates AranyaClientConfigBuilder.
 */
AranyaError aranya_client_config_builder_set_daemon_uds_path_ext(struct AranyaClientConfigBuilder *cfg,
                                                                 const char *address,
                                                                 struct AranyaExtError *__ext_err);

/**
 * Initializes `AranyaAqcConfigBuilder`.
 *
 * When no longer needed, `out`'s resources must be released
 * with its cleanup routine.
 *
 * @relates AranyaAqcConfigBuilder
 */
AranyaError aranya_aqc_config_builder_init(struct AranyaAqcConfigBuilder *out);

/**
 * Initializes `AranyaAqcConfigBuilder`.
 *
 * When no longer needed, `out`'s resources must be released
 * with its cleanup routine.
 *
 * @relates AranyaAqcConfigBuilder
 */
AranyaError aranya_aqc_config_builder_init_ext(struct AranyaAqcConfigBuilder *out,
                                               struct AranyaExtError *__ext_err);

/**
 * Releases any resources associated with `ptr`.
 *
 * `ptr` must either be null or initialized by `::aranya_aqc_config_builder_init`.
 *
 * @relates AranyaAqcConfigBuilder
 */
AranyaError aranya_aqc_config_builder_cleanup(struct AranyaAqcConfigBuilder *ptr);

/**
 * Releases any resources associated with `ptr`.
 *
 * `ptr` must either be null or initialized by `::aranya_aqc_config_builder_init`.
 *
 * @relates AranyaAqcConfigBuilder
 */
AranyaError aranya_aqc_config_builder_cleanup_ext(struct AranyaAqcConfigBuilder *ptr,
                                                  struct AranyaExtError *__ext_err);

/**
 * Attempts to construct an [`AranyaAqcConfig`](@ref AranyaAqcConfig).
 *
 * This function consumes and releases any resources associated
 * with the memory pointed to by `cfg`.
 *
 * @param cfg a pointer to the aqc config builder
 * @param out a pointer to write the aqc config to
 *
 * @relates AranyaAqcConfigBuilder.
 */
AranyaError aranya_aqc_config_build(struct AranyaAqcConfigBuilder *cfg,
                                    struct AranyaAqcConfig *out);

/**
 * Attempts to construct an [`AranyaAqcConfig`](@ref AranyaAqcConfig).
 *
 * This function consumes and releases any resources associated
 * with the memory pointed to by `cfg`.
 *
 * @param cfg a pointer to the aqc config builder
 * @param out a pointer to write the aqc config to
 *
 * @relates AranyaAqcConfigBuilder.
 */
AranyaError aranya_aqc_config_build_ext(struct AranyaAqcConfigBuilder *cfg,
                                        struct AranyaAqcConfig *out,
                                        struct AranyaExtError *__ext_err);

/**
 * Sets the network address that the AQC server should listen
 * on.
 *
 * @param cfg a pointer to the aqc config builder
 * @param address a string with the address to bind to
 *
 * @relates AranyaAqcConfigBuilder.
 */
AranyaError aranya_aqc_config_builder_set_address(struct AranyaAqcConfigBuilder *cfg,
                                                  const char *address);

/**
 * Sets the network address that the AQC server should listen
 * on.
 *
 * @param cfg a pointer to the aqc config builder
 * @param address a string with the address to bind to
 *
 * @relates AranyaAqcConfigBuilder.
 */
AranyaError aranya_aqc_config_builder_set_address_ext(struct AranyaAqcConfigBuilder *cfg,
                                                      const char *address,
                                                      struct AranyaExtError *__ext_err);

/**
 * Sets the configuration for Aranya QUIC Channels.
 *
 * @param cfg a pointer to the client config builder
 * @param aqc_config a pointer to a valid AQC config (see [`AranyaAqcConfigBuilder`](@ref AranyaAqcConfigBuilder))
 *
 * @relates AranyaAqcConfigBuilder.
 */
AranyaError aranya_client_config_builder_set_aqc_config(struct AranyaClientConfigBuilder *cfg,
                                                        const struct AranyaAqcConfig *aqc_config);

/**
 * Sets the configuration for Aranya QUIC Channels.
 *
 * @param cfg a pointer to the client config builder
 * @param aqc_config a pointer to a valid AQC config (see [`AranyaAqcConfigBuilder`](@ref AranyaAqcConfigBuilder))
 *
 * @relates AranyaAqcConfigBuilder.
 */
AranyaError aranya_client_config_builder_set_aqc_config_ext(struct AranyaClientConfigBuilder *cfg,
                                                            const struct AranyaAqcConfig *aqc_config,
                                                            struct AranyaExtError *__ext_err);

/**
 * Initializes `AranyaQuicSyncConfigBuilder`.
 *
 * When no longer needed, `out`'s resources must be released
 * with its cleanup routine.
 *
 * @relates AranyaQuicSyncConfigBuilder
 */
AranyaError aranya_quic_sync_config_builder_init(struct AranyaQuicSyncConfigBuilder *out);

/**
 * Initializes `AranyaQuicSyncConfigBuilder`.
 *
 * When no longer needed, `out`'s resources must be released
 * with its cleanup routine.
 *
 * @relates AranyaQuicSyncConfigBuilder
 */
AranyaError aranya_quic_sync_config_builder_init_ext(struct AranyaQuicSyncConfigBuilder *out,
                                                     struct AranyaExtError *__ext_err);

/**
 * Releases any resources associated with `ptr`.
 *
 * `ptr` must either be null or initialized by `::aranya_quic_sync_config_builder_init`.
 *
 * @relates AranyaQuicSyncConfigBuilder
 */
AranyaError aranya_quic_sync_config_builder_cleanup(struct AranyaQuicSyncConfigBuilder *ptr);

/**
 * Releases any resources associated with `ptr`.
 *
 * `ptr` must either be null or initialized by `::aranya_quic_sync_config_builder_init`.
 *
 * @relates AranyaQuicSyncConfigBuilder
 */
AranyaError aranya_quic_sync_config_builder_cleanup_ext(struct AranyaQuicSyncConfigBuilder *ptr,
                                                        struct AranyaExtError *__ext_err);

/**
 * Attempts to set PSK seed generation mode value on [`AranyaQuicSyncConfigBuilder`](@ref AranyaQuicSyncConfigBuilder).
 *
 * @param cfg a pointer to the quic sync config builder
 *
 * @relates AranyaQuicSyncConfigBuilder.
 */
AranyaError aranya_quic_sync_config_generate(struct AranyaQuicSyncConfigBuilder *cfg);

/**
 * Attempts to set PSK seed generation mode value on [`AranyaQuicSyncConfigBuilder`](@ref AranyaQuicSyncConfigBuilder).
 *
 * @param cfg a pointer to the quic sync config builder
 *
 * @relates AranyaQuicSyncConfigBuilder.
 */
AranyaError aranya_quic_sync_config_generate_ext(struct AranyaQuicSyncConfigBuilder *cfg,
                                                 struct AranyaExtError *__ext_err);

/**
 * Attempts to set wrapped PSK seed value on [`AranyaQuicSyncConfigBuilder`](@ref AranyaQuicSyncConfigBuilder).
 *
 * @param cfg a pointer to the quic sync config builder
 * @param encap_seed a pointer the encapsulated PSK seed
 *
 * @relates AranyaQuicSyncConfigBuilder.
 */
AranyaError aranya_quic_sync_config_wrapped_seed(struct AranyaQuicSyncConfigBuilder *cfg,
                                                 const uint8_t *encap_seed,
                                                 size_t encap_seed_len);

/**
 * Attempts to set wrapped PSK seed value on [`AranyaQuicSyncConfigBuilder`](@ref AranyaQuicSyncConfigBuilder).
 *
 * @param cfg a pointer to the quic sync config builder
 * @param encap_seed a pointer the encapsulated PSK seed
 *
 * @relates AranyaQuicSyncConfigBuilder.
 */
AranyaError aranya_quic_sync_config_wrapped_seed_ext(struct AranyaQuicSyncConfigBuilder *cfg,
                                                     const uint8_t *encap_seed,
                                                     size_t encap_seed_len,
                                                     struct AranyaExtError *__ext_err);

/**
 * Attempts to set raw PSK seed IKM value [`AranyaSeedIkm`](@ref AranyaSeedIkm) on [`AranyaQuicSyncConfigBuilder`](@ref AranyaQuicSyncConfigBuilder).
 *
 * @param cfg a pointer to the quic sync config builder [`AranyaQuicSyncConfigBuilder`](@ref AranyaQuicSyncConfigBuilder)
 * @param ikm a pointer the raw PSK seed IKM [`AranyaSeedIkm`](@ref AranyaSeedIkm)
 *
 * @relates AranyaQuicSyncConfigBuilder.
 */
AranyaError aranya_quic_sync_config_raw_seed_ikm(struct AranyaQuicSyncConfigBuilder *cfg,
                                                 const struct AranyaSeedIkm *ikm);

/**
 * Attempts to set raw PSK seed IKM value [`AranyaSeedIkm`](@ref AranyaSeedIkm) on [`AranyaQuicSyncConfigBuilder`](@ref AranyaQuicSyncConfigBuilder).
 *
 * @param cfg a pointer to the quic sync config builder [`AranyaQuicSyncConfigBuilder`](@ref AranyaQuicSyncConfigBuilder)
 * @param ikm a pointer the raw PSK seed IKM [`AranyaSeedIkm`](@ref AranyaSeedIkm)
 *
 * @relates AranyaQuicSyncConfigBuilder.
 */
AranyaError aranya_quic_sync_config_raw_seed_ikm_ext(struct AranyaQuicSyncConfigBuilder *cfg,
                                                     const struct AranyaSeedIkm *ikm,
                                                     struct AranyaExtError *__ext_err);

/**
 * Attempts to construct a [`AranyaQuicSyncConfig`](@ref AranyaQuicSyncConfig).
 *
 * This function consumes and releases any resources associated
 * with the memory pointed to by `cfg`.
 *
 * @param cfg a pointer to the QUIC sync config builder [`AranyaQuicSyncConfigBuilder`](@ref AranyaQuicSyncConfigBuilder)
 * @param out a pointer to write the QUIC sync config to [`AranyaQuicSyncConfig`](@ref AranyaQuicSyncConfig)
 *
 * @relates AranyaQuicSyncConfigBuilder.
 */
AranyaError aranya_quic_sync_config_build(struct AranyaQuicSyncConfigBuilder *cfg,
                                          struct AranyaQuicSyncConfig *out);

/**
 * Attempts to construct a [`AranyaQuicSyncConfig`](@ref AranyaQuicSyncConfig).
 *
 * This function consumes and releases any resources associated
 * with the memory pointed to by `cfg`.
 *
 * @param cfg a pointer to the QUIC sync config builder [`AranyaQuicSyncConfigBuilder`](@ref AranyaQuicSyncConfigBuilder)
 * @param out a pointer to write the QUIC sync config to [`AranyaQuicSyncConfig`](@ref AranyaQuicSyncConfig)
 *
 * @relates AranyaQuicSyncConfigBuilder.
 */
AranyaError aranya_quic_sync_config_build_ext(struct AranyaQuicSyncConfigBuilder *cfg,
                                              struct AranyaQuicSyncConfig *out,
                                              struct AranyaExtError *__ext_err);

/**
 * Initializes `AranyaTeamConfigBuilder`.
 *
 * When no longer needed, `out`'s resources must be released
 * with its cleanup routine.
 *
 * @relates AranyaTeamConfigBuilder
 */
AranyaError aranya_team_config_builder_init(struct AranyaTeamConfigBuilder *out);

/**
 * Initializes `AranyaTeamConfigBuilder`.
 *
 * When no longer needed, `out`'s resources must be released
 * with its cleanup routine.
 *
 * @relates AranyaTeamConfigBuilder
 */
AranyaError aranya_team_config_builder_init_ext(struct AranyaTeamConfigBuilder *out,
                                                struct AranyaExtError *__ext_err);

/**
 * Releases any resources associated with `ptr`.
 *
 * `ptr` must either be null or initialized by `::aranya_team_config_builder_init`.
 *
 * @relates AranyaTeamConfigBuilder
 */
AranyaError aranya_team_config_builder_cleanup(struct AranyaTeamConfigBuilder *ptr);

/**
 * Releases any resources associated with `ptr`.
 *
 * `ptr` must either be null or initialized by `::aranya_team_config_builder_init`.
 *
 * @relates AranyaTeamConfigBuilder
 */
AranyaError aranya_team_config_builder_cleanup_ext(struct AranyaTeamConfigBuilder *ptr,
                                                   struct AranyaExtError *__ext_err);

/**
 * Configures QUIC syncer for [`AranyaTeamConfigBuilder`](@ref AranyaTeamConfigBuilder).
 *
 * By default, the QUIC syncer config is not set. It is an error to call
 * [`aranya_team_config_build`](@ref aranya_team_config_build) before setting the interval with
 * this function
 *
 * @param cfg a pointer to the builder for a team config [`AranyaTeamConfigBuilder`](@ref AranyaTeamConfigBuilder)
 * @param quic set the QUIC syncer config [`AranyaQuicSyncConfig`](@ref AranyaQuicSyncConfig)
 *
 * @relates AranyaTeamConfigBuilder.
 */
AranyaError aranya_team_config_builder_set_quic_syncer(struct AranyaTeamConfigBuilder *cfg,
                                                       struct AranyaQuicSyncConfig *quic);

/**
 * Configures QUIC syncer for [`AranyaTeamConfigBuilder`](@ref AranyaTeamConfigBuilder).
 *
 * By default, the QUIC syncer config is not set. It is an error to call
 * [`aranya_team_config_build`](@ref aranya_team_config_build) before setting the interval with
 * this function
 *
 * @param cfg a pointer to the builder for a team config [`AranyaTeamConfigBuilder`](@ref AranyaTeamConfigBuilder)
 * @param quic set the QUIC syncer config [`AranyaQuicSyncConfig`](@ref AranyaQuicSyncConfig)
 *
 * @relates AranyaTeamConfigBuilder.
 */
AranyaError aranya_team_config_builder_set_quic_syncer_ext(struct AranyaTeamConfigBuilder *cfg,
                                                           struct AranyaQuicSyncConfig *quic,
                                                           struct AranyaExtError *__ext_err);

/**
 * Attempts to construct a [`AranyaTeamConfig`](@ref AranyaTeamConfig).
 *
 * This function consumes and releases any resources associated
 * with the memory pointed to by `cfg`.
 *
 * @param cfg a pointer to the team config builder [`AranyaTeamConfigBuilder`](@ref AranyaTeamConfigBuilder)
 * @param out a pointer to write the team config to [`AranyaTeamConfig`](@ref AranyaTeamConfig)
 *
 * @relates AranyaTeamConfigBuilder.
 */
AranyaError aranya_team_config_build(struct AranyaTeamConfigBuilder *cfg,
                                     struct AranyaTeamConfig *out);

/**
 * Attempts to construct a [`AranyaTeamConfig`](@ref AranyaTeamConfig).
 *
 * This function consumes and releases any resources associated
 * with the memory pointed to by `cfg`.
 *
 * @param cfg a pointer to the team config builder [`AranyaTeamConfigBuilder`](@ref AranyaTeamConfigBuilder)
 * @param out a pointer to write the team config to [`AranyaTeamConfig`](@ref AranyaTeamConfig)
 *
 * @relates AranyaTeamConfigBuilder.
 */
AranyaError aranya_team_config_build_ext(struct AranyaTeamConfigBuilder *cfg,
                                         struct AranyaTeamConfig *out,
                                         struct AranyaExtError *__ext_err);

/**
 * Initializes `AranyaSyncPeerConfigBuilder`.
 *
 * When no longer needed, `out`'s resources must be released
 * with its cleanup routine.
 *
 * @relates AranyaSyncPeerConfigBuilder
 */
AranyaError aranya_sync_peer_config_builder_init(struct AranyaSyncPeerConfigBuilder *out);

/**
 * Initializes `AranyaSyncPeerConfigBuilder`.
 *
 * When no longer needed, `out`'s resources must be released
 * with its cleanup routine.
 *
 * @relates AranyaSyncPeerConfigBuilder
 */
AranyaError aranya_sync_peer_config_builder_init_ext(struct AranyaSyncPeerConfigBuilder *out,
                                                     struct AranyaExtError *__ext_err);

/**
 * Releases any resources associated with `ptr`.
 *
 * `ptr` must either be null or initialized by `::aranya_sync_peer_config_builder_init`.
 *
 * @relates AranyaSyncPeerConfigBuilder
 */
AranyaError aranya_sync_peer_config_builder_cleanup(struct AranyaSyncPeerConfigBuilder *ptr);

/**
 * Releases any resources associated with `ptr`.
 *
 * `ptr` must either be null or initialized by `::aranya_sync_peer_config_builder_init`.
 *
 * @relates AranyaSyncPeerConfigBuilder
 */
AranyaError aranya_sync_peer_config_builder_cleanup_ext(struct AranyaSyncPeerConfigBuilder *ptr,
                                                        struct AranyaExtError *__ext_err);

/**
 * Attempts to build a [`AranyaSyncPeerConfig`](@ref AranyaSyncPeerConfig).
 *
 * This function consumes and releases any resources associated
 * with the memory pointed to by `cfg`.
 *
 * @param cfg a pointer to the builder for a sync config [`AranyaSyncPeerConfigBuilder`](@ref AranyaSyncPeerConfigBuilder)
 * @param out a pointer to write the sync config to [`AranyaSyncPeerConfig`](@ref AranyaSyncPeerConfig)
 *
 * @relates AranyaSyncPeerConfigBuilder.
 */
AranyaError aranya_sync_peer_config_build(struct AranyaSyncPeerConfigBuilder *cfg,
                                          struct AranyaSyncPeerConfig *out);

/**
 * Attempts to build a [`AranyaSyncPeerConfig`](@ref AranyaSyncPeerConfig).
 *
 * This function consumes and releases any resources associated
 * with the memory pointed to by `cfg`.
 *
 * @param cfg a pointer to the builder for a sync config [`AranyaSyncPeerConfigBuilder`](@ref AranyaSyncPeerConfigBuilder)
 * @param out a pointer to write the sync config to [`AranyaSyncPeerConfig`](@ref AranyaSyncPeerConfig)
 *
 * @relates AranyaSyncPeerConfigBuilder.
 */
AranyaError aranya_sync_peer_config_build_ext(struct AranyaSyncPeerConfigBuilder *cfg,
                                              struct AranyaSyncPeerConfig *out,
                                              struct AranyaExtError *__ext_err);

/**
 * Configures how often the peer will be synced with.
 *
 * By default, the interval is not set. It is an error to call
 * [`aranya_sync_peer_config_build`](@ref aranya_sync_peer_config_build) before setting the interval with
 * this function
 *
 * @param cfg a pointer to the builder for a sync config
 * @param interval Set the interval at which syncing occurs
 *
 * @relates AranyaSyncPeerConfigBuilder.
 */
AranyaError aranya_sync_peer_config_builder_set_interval(struct AranyaSyncPeerConfigBuilder *cfg,
                                                         AranyaDuration interval);

/**
 * Configures how often the peer will be synced with.
 *
 * By default, the interval is not set. It is an error to call
 * [`aranya_sync_peer_config_build`](@ref aranya_sync_peer_config_build) before setting the interval with
 * this function
 *
 * @param cfg a pointer to the builder for a sync config
 * @param interval Set the interval at which syncing occurs
 *
 * @relates AranyaSyncPeerConfigBuilder.
 */
AranyaError aranya_sync_peer_config_builder_set_interval_ext(struct AranyaSyncPeerConfigBuilder *cfg,
                                                             AranyaDuration interval,
                                                             struct AranyaExtError *__ext_err);

/**
 * Updates the config to enable immediate syncing with the peer.
 *
 * Overrides [`aranya_sync_peer_config_builder_set_sync_later`](@ref aranya_sync_peer_config_builder_set_sync_later) if invoked afterward.
 *
 * By default, the peer is synced with immediately.
 *
 * @param cfg a pointer to the builder for a sync config
 *
 * @relates AranyaSyncPeerConfigBuilder.
 */
AranyaError aranya_sync_peer_config_builder_set_sync_now(struct AranyaSyncPeerConfigBuilder *cfg);

/**
 * Updates the config to enable immediate syncing with the peer.
 *
 * Overrides [`aranya_sync_peer_config_builder_set_sync_later`](@ref aranya_sync_peer_config_builder_set_sync_later) if invoked afterward.
 *
 * By default, the peer is synced with immediately.
 *
 * @param cfg a pointer to the builder for a sync config
 *
 * @relates AranyaSyncPeerConfigBuilder.
 */
AranyaError aranya_sync_peer_config_builder_set_sync_now_ext(struct AranyaSyncPeerConfigBuilder *cfg,
                                                             struct AranyaExtError *__ext_err);

/**
 * Updates the config to disable immediate syncing with the peer.
 *
 * Overrides [`aranya_sync_peer_config_builder_set_sync_now`](@ref aranya_sync_peer_config_builder_set_sync_now) if invoked afterward.
 *
 * By default, the peer is synced with immediately.
 * @param cfg a pointer to the builder for a sync config
 *
 * @relates AranyaSyncPeerConfigBuilder.
 */
AranyaError aranya_sync_peer_config_builder_set_sync_later(struct AranyaSyncPeerConfigBuilder *cfg);

/**
 * Updates the config to disable immediate syncing with the peer.
 *
 * Overrides [`aranya_sync_peer_config_builder_set_sync_now`](@ref aranya_sync_peer_config_builder_set_sync_now) if invoked afterward.
 *
 * By default, the peer is synced with immediately.
 * @param cfg a pointer to the builder for a sync config
 *
 * @relates AranyaSyncPeerConfigBuilder.
 */
AranyaError aranya_sync_peer_config_builder_set_sync_later_ext(struct AranyaSyncPeerConfigBuilder *cfg,
                                                               struct AranyaExtError *__ext_err);

/**
 * Assign a role to a device.
 *
 * This will change the device's current role to the new role assigned.
 *
 * Permission to perform this operation is checked against the Aranya policy.
 *
 * @param client the Aranya Client [`AranyaClient`](@ref AranyaClient).
 * @param team the team's ID [`AranyaTeamId`](@ref AranyaTeamId).
 * @param device the device's ID [`AranyaDeviceId`](@ref AranyaDeviceId).
 * @param role the role [`AranyaRole`](@ref AranyaRole) to assign to the device.
 *
 * @relates AranyaClient.
 */
AranyaError aranya_assign_role(struct AranyaClient *client,
                               const struct AranyaTeamId *team,
                               const struct AranyaDeviceId *device,
                               AranyaRole role);

/**
 * Assign a role to a device.
 *
 * This will change the device's current role to the new role assigned.
 *
 * Permission to perform this operation is checked against the Aranya policy.
 *
 * @param client the Aranya Client [`AranyaClient`](@ref AranyaClient).
 * @param team the team's ID [`AranyaTeamId`](@ref AranyaTeamId).
 * @param device the device's ID [`AranyaDeviceId`](@ref AranyaDeviceId).
 * @param role the role [`AranyaRole`](@ref AranyaRole) to assign to the device.
 *
 * @relates AranyaClient.
 */
AranyaError aranya_assign_role_ext(struct AranyaClient *client,
                                   const struct AranyaTeamId *team,
                                   const struct AranyaDeviceId *device,
                                   AranyaRole role,
                                   struct AranyaExtError *__ext_err);

/**
 * Revoke a role from a device.
 *
 * Permission to perform this operation is checked against the Aranya policy.
 *
 * @param client the Aranya Client [`AranyaClient`](@ref AranyaClient).
 * @param team the team's ID [`AranyaTeamId`](@ref AranyaTeamId).
 * @param device the device's ID [`AranyaDeviceId`](@ref AranyaDeviceId).
 * @param role the role [`AranyaRole`](@ref AranyaRole) to revoke from the device.
 *
 * @relates AranyaClient.
 */
AranyaError aranya_revoke_role(struct AranyaClient *client,
                               const struct AranyaTeamId *team,
                               const struct AranyaDeviceId *device,
                               AranyaRole role);

/**
 * Revoke a role from a device.
 *
 * Permission to perform this operation is checked against the Aranya policy.
 *
 * @param client the Aranya Client [`AranyaClient`](@ref AranyaClient).
 * @param team the team's ID [`AranyaTeamId`](@ref AranyaTeamId).
 * @param device the device's ID [`AranyaDeviceId`](@ref AranyaDeviceId).
 * @param role the role [`AranyaRole`](@ref AranyaRole) to revoke from the device.
 *
 * @relates AranyaClient.
 */
AranyaError aranya_revoke_role_ext(struct AranyaClient *client,
                                   const struct AranyaTeamId *team,
                                   const struct AranyaDeviceId *device,
                                   AranyaRole role,
                                   struct AranyaExtError *__ext_err);

/**
 * Create a channel label.
 *
 * Permission to perform this operation is checked against the Aranya policy.
 *
 * @param client the Aranya Client [`AranyaClient`](@ref AranyaClient).
 * @param team the team's ID [`AranyaTeamId`](@ref AranyaTeamId).
 * @param name label name string [`AranyaLabelName`](@ref AranyaLabelName).
 *
 * @relates AranyaClient.
 */
AranyaError aranya_create_label(struct AranyaClient *client,
                                const struct AranyaTeamId *team,
                                AranyaLabelName name,
                                struct AranyaLabelId *__output);

/**
 * Create a channel label.
 *
 * Permission to perform this operation is checked against the Aranya policy.
 *
 * @param client the Aranya Client [`AranyaClient`](@ref AranyaClient).
 * @param team the team's ID [`AranyaTeamId`](@ref AranyaTeamId).
 * @param name label name string [`AranyaLabelName`](@ref AranyaLabelName).
 *
 * @relates AranyaClient.
 */
AranyaError aranya_create_label_ext(struct AranyaClient *client,
                                    const struct AranyaTeamId *team,
                                    AranyaLabelName name,
                                    struct AranyaLabelId *__output,
                                    struct AranyaExtError *__ext_err);

/**
 * Delete a channel label.
 *
 * Permission to perform this operation is checked against the Aranya policy.
 *
 * @param client the Aranya Client [`AranyaClient`](@ref AranyaClient).
 * @param team the team's ID [`AranyaTeamId`](@ref AranyaTeamId).
 * @param label_id the channel label ID [`AranyaLabelId`](@ref AranyaLabelId) to delete.
 *
 * @relates AranyaClient.
 */
AranyaError aranya_delete_label(struct AranyaClient *client,
                                const struct AranyaTeamId *team,
                                const struct AranyaLabelId *label_id);

/**
 * Delete a channel label.
 *
 * Permission to perform this operation is checked against the Aranya policy.
 *
 * @param client the Aranya Client [`AranyaClient`](@ref AranyaClient).
 * @param team the team's ID [`AranyaTeamId`](@ref AranyaTeamId).
 * @param label_id the channel label ID [`AranyaLabelId`](@ref AranyaLabelId) to delete.
 *
 * @relates AranyaClient.
 */
AranyaError aranya_delete_label_ext(struct AranyaClient *client,
                                    const struct AranyaTeamId *team,
                                    const struct AranyaLabelId *label_id,
                                    struct AranyaExtError *__ext_err);

/**
 * Assign a label to a device so that it can be used for a channel.
 *
 * Permission to perform this operation is checked against the Aranya policy.
 *
 * @param client the Aranya Client [`AranyaClient`](@ref AranyaClient).
 * @param team the team's ID [`AranyaTeamId`](@ref AranyaTeamId).
 * @param device the device ID [`AranyaDeviceId`](@ref AranyaDeviceId) of the device to assign the label to.
 * @param label_id the AQC channel label ID [`AranyaLabelId`](@ref AranyaLabelId).
 *
 * @relates AranyaClient.
 */
AranyaError aranya_assign_label(struct AranyaClient *client,
                                const struct AranyaTeamId *team,
                                const struct AranyaDeviceId *device,
                                const struct AranyaLabelId *label_id,
                                AranyaChanOp op);

/**
 * Assign a label to a device so that it can be used for a channel.
 *
 * Permission to perform this operation is checked against the Aranya policy.
 *
 * @param client the Aranya Client [`AranyaClient`](@ref AranyaClient).
 * @param team the team's ID [`AranyaTeamId`](@ref AranyaTeamId).
 * @param device the device ID [`AranyaDeviceId`](@ref AranyaDeviceId) of the device to assign the label to.
 * @param label_id the AQC channel label ID [`AranyaLabelId`](@ref AranyaLabelId).
 *
 * @relates AranyaClient.
 */
AranyaError aranya_assign_label_ext(struct AranyaClient *client,
                                    const struct AranyaTeamId *team,
                                    const struct AranyaDeviceId *device,
                                    const struct AranyaLabelId *label_id,
                                    AranyaChanOp op,
                                    struct AranyaExtError *__ext_err);

/**
 * Revoke a label from a device.
 *
 * Permission to perform this operation is checked against the Aranya policy.
 *
 * @param client the Aranya Client [`AranyaClient`](@ref AranyaClient).
 * @param team the team's ID [`AranyaTeamId`](@ref AranyaTeamId).
 * @param device the device ID [`AranyaDeviceId`](@ref AranyaDeviceId) of the device to revoke the label from.
 * @param label_id the AQC channel label ID [`AranyaLabelId`](@ref AranyaLabelId).
 *
 * @relates AranyaClient.
 */
AranyaError aranya_revoke_label(struct AranyaClient *client,
                                const struct AranyaTeamId *team,
                                const struct AranyaDeviceId *device,
                                const struct AranyaLabelId *label_id);

/**
 * Revoke a label from a device.
 *
 * Permission to perform this operation is checked against the Aranya policy.
 *
 * @param client the Aranya Client [`AranyaClient`](@ref AranyaClient).
 * @param team the team's ID [`AranyaTeamId`](@ref AranyaTeamId).
 * @param device the device ID [`AranyaDeviceId`](@ref AranyaDeviceId) of the device to revoke the label from.
 * @param label_id the AQC channel label ID [`AranyaLabelId`](@ref AranyaLabelId).
 *
 * @relates AranyaClient.
 */
AranyaError aranya_revoke_label_ext(struct AranyaClient *client,
                                    const struct AranyaTeamId *team,
                                    const struct AranyaDeviceId *device,
                                    const struct AranyaLabelId *label_id,
                                    struct AranyaExtError *__ext_err);

/**
 * Create a new graph/team with the current device as the owner.
 *
 * @param client the Aranya Client [`AranyaClient`](@ref AranyaClient).
 * @param cfg the Team Configuration [`AranyaTeamConfig`](@ref AranyaTeamConfig).
 * @param __output the team's ID [`AranyaTeamId`](@ref AranyaTeamId).
 *
 * @relates AranyaClient.
 */
AranyaError aranya_create_team(struct AranyaClient *client,
                               const struct AranyaTeamConfig *cfg,
                               struct AranyaTeamId *__output);

/**
 * Create a new graph/team with the current device as the owner.
 *
 * @param client the Aranya Client [`AranyaClient`](@ref AranyaClient).
 * @param cfg the Team Configuration [`AranyaTeamConfig`](@ref AranyaTeamConfig).
 * @param __output the team's ID [`AranyaTeamId`](@ref AranyaTeamId).
 *
 * @relates AranyaClient.
 */
AranyaError aranya_create_team_ext(struct AranyaClient *client,
                                   const struct AranyaTeamConfig *cfg,
                                   struct AranyaTeamId *__output,
                                   struct AranyaExtError *__ext_err);

/**
 * Return random bytes from Aranya's CSPRNG.
 *
 * This method can be used to generate a PSK seed IKM for the QUIC syncer.
 *
 * @param[in] client the Aranya Client [`AranyaClient`](@ref AranyaClient).
 * @param[out] buf buffer where random bytes are written to.
 * @param[in] buf_len the size of the buffer.
 */
AranyaError aranya_rand(struct AranyaClient *client,
                        uint8_t *buf,
                        size_t buf_len);

/**
 * Return random bytes from Aranya's CSPRNG.
 *
 * This method can be used to generate a PSK seed IKM for the QUIC syncer.
 *
 * @param[in] client the Aranya Client [`AranyaClient`](@ref AranyaClient).
 * @param[out] buf buffer where random bytes are written to.
 * @param[in] buf_len the size of the buffer.
 */
AranyaError aranya_rand_ext(struct AranyaClient *client,
                            uint8_t *buf,
                            size_t buf_len,
                            struct AranyaExtError *__ext_err);

/**
 * Return serialized PSK seed encrypted for another device on the team.
 *
 * The PSK seed will be encrypted using the public encryption key of the specified device on the team.
 *
 * Returns an `AranyaBufferTooSmall` error if the output buffer is too small to hold the seed bytes.
 * Writes the number of bytes that would have been returned to `seed_len`.
 * The application can use `seed_len` to allocate a larger buffer.
 *
 * @param[in] client the Aranya Client [`AranyaClient`](@ref AranyaClient).
 * @param[in] team_id the team's ID [`AranyaTeamId`](@ref AranyaTeamId).
 * @param[in] keybundle serialized keybundle byte buffer `KeyBundle`.
 * @param[out] seed the serialized, encrypted PSK seed.
 * @param[out] seed_len the number of bytes written to the seed buffer.
 *
 * @relates AranyaClient.
 */
AranyaError aranya_encrypt_psk_seed_for_peer(struct AranyaClient *client,
                                             const struct AranyaTeamId *team_id,
                                             const uint8_t *keybundle,
                                             size_t keybundle_len,
                                             uint8_t *seed,
                                             size_t *seed_len);

/**
 * Return serialized PSK seed encrypted for another device on the team.
 *
 * The PSK seed will be encrypted using the public encryption key of the specified device on the team.
 *
 * Returns an `AranyaBufferTooSmall` error if the output buffer is too small to hold the seed bytes.
 * Writes the number of bytes that would have been returned to `seed_len`.
 * The application can use `seed_len` to allocate a larger buffer.
 *
 * @param[in] client the Aranya Client [`AranyaClient`](@ref AranyaClient).
 * @param[in] team_id the team's ID [`AranyaTeamId`](@ref AranyaTeamId).
 * @param[in] keybundle serialized keybundle byte buffer `KeyBundle`.
 * @param[out] seed the serialized, encrypted PSK seed.
 * @param[out] seed_len the number of bytes written to the seed buffer.
 *
 * @relates AranyaClient.
 */
AranyaError aranya_encrypt_psk_seed_for_peer_ext(struct AranyaClient *client,
                                                 const struct AranyaTeamId *team_id,
                                                 const uint8_t *keybundle,
                                                 size_t keybundle_len,
                                                 uint8_t *seed,
                                                 size_t *seed_len,
                                                 struct AranyaExtError *__ext_err);

/**
 * Add a team to the local device store.
 *
 * @param client the Aranya Client [`AranyaClient`](@ref AranyaClient).
 * @param team the team's ID [`AranyaTeamId`](@ref AranyaTeamId).
 * @param cfg the Team Configuration [`AranyaTeamConfig`](@ref AranyaTeamConfig).
 *
 * @relates AranyaClient.
 */
AranyaError aranya_add_team(struct AranyaClient *client,
                            const struct AranyaTeamId *team,
                            const struct AranyaTeamConfig *cfg);

/**
 * Add a team to the local device store.
 *
 * @param client the Aranya Client [`AranyaClient`](@ref AranyaClient).
 * @param team the team's ID [`AranyaTeamId`](@ref AranyaTeamId).
 * @param cfg the Team Configuration [`AranyaTeamConfig`](@ref AranyaTeamConfig).
 *
 * @relates AranyaClient.
 */
AranyaError aranya_add_team_ext(struct AranyaClient *client,
                                const struct AranyaTeamId *team,
                                const struct AranyaTeamConfig *cfg,
                                struct AranyaExtError *__ext_err);

/**
 * Remove a team from local device storage.
 *
 * @param client the Aranya Client [`AranyaClient`](@ref AranyaClient).
 * @param team the team's ID [`AranyaTeamId`](@ref AranyaTeamId).
 *
 * @relates AranyaClient.
 */
AranyaError aranya_remove_team(struct AranyaClient *client,
                               const struct AranyaTeamId *team);

/**
 * Remove a team from local device storage.
 *
 * @param client the Aranya Client [`AranyaClient`](@ref AranyaClient).
 * @param team the team's ID [`AranyaTeamId`](@ref AranyaTeamId).
 *
 * @relates AranyaClient.
 */
AranyaError aranya_remove_team_ext(struct AranyaClient *client,
                                   const struct AranyaTeamId *team,
                                   struct AranyaExtError *__ext_err);

/**
 * Close the team and stop all operations on the graph.
 *
 * @param client the Aranya Client [`AranyaClient`](@ref AranyaClient).
 * @param team the team's ID [`AranyaTeamId`](@ref AranyaTeamId).
 *
 * @relates AranyaClient.
 */
AranyaError aranya_close_team(struct AranyaClient *client,
                              const struct AranyaTeamId *team);

/**
 * Close the team and stop all operations on the graph.
 *
 * @param client the Aranya Client [`AranyaClient`](@ref AranyaClient).
 * @param team the team's ID [`AranyaTeamId`](@ref AranyaTeamId).
 *
 * @relates AranyaClient.
 */
AranyaError aranya_close_team_ext(struct AranyaClient *client,
                                  const struct AranyaTeamId *team,
                                  struct AranyaExtError *__ext_err);

/**
 * Add a device to the team with the default role.
 *
 * Permission to perform this operation is checked against the Aranya policy.
 *
 * @param client the Aranya Client [`AranyaClient`](@ref AranyaClient).
 * @param team the team's ID [`AranyaTeamId`](@ref AranyaTeamId).
 * @param keybundle serialized keybundle byte buffer `KeyBundle`.
 * @param keybundle_len is the length of the serialized keybundle.
 *
 * @relates AranyaClient.
 */
AranyaError aranya_add_device_to_team(struct AranyaClient *client,
                                      const struct AranyaTeamId *team,
                                      const uint8_t *keybundle,
                                      size_t keybundle_len);

/**
 * Add a device to the team with the default role.
 *
 * Permission to perform this operation is checked against the Aranya policy.
 *
 * @param client the Aranya Client [`AranyaClient`](@ref AranyaClient).
 * @param team the team's ID [`AranyaTeamId`](@ref AranyaTeamId).
 * @param keybundle serialized keybundle byte buffer `KeyBundle`.
 * @param keybundle_len is the length of the serialized keybundle.
 *
 * @relates AranyaClient.
 */
AranyaError aranya_add_device_to_team_ext(struct AranyaClient *client,
                                          const struct AranyaTeamId *team,
                                          const uint8_t *keybundle,
                                          size_t keybundle_len,
                                          struct AranyaExtError *__ext_err);

/**
 * Remove a device from the team.
 *
 * Permission to perform this operation is checked against the Aranya policy.
 *
 * @param client the Aranya Client [`AranyaClient`](@ref AranyaClient).
 * @param team the team's ID [`AranyaTeamId`](@ref AranyaTeamId).
 * @param device the device's ID [`AranyaDeviceId`](@ref AranyaDeviceId).
 *
 * @relates AranyaClient.
 */
AranyaError aranya_remove_device_from_team(struct AranyaClient *client,
                                           const struct AranyaTeamId *team,
                                           const struct AranyaDeviceId *device);

/**
 * Remove a device from the team.
 *
 * Permission to perform this operation is checked against the Aranya policy.
 *
 * @param client the Aranya Client [`AranyaClient`](@ref AranyaClient).
 * @param team the team's ID [`AranyaTeamId`](@ref AranyaTeamId).
 * @param device the device's ID [`AranyaDeviceId`](@ref AranyaDeviceId).
 *
 * @relates AranyaClient.
 */
AranyaError aranya_remove_device_from_team_ext(struct AranyaClient *client,
                                               const struct AranyaTeamId *team,
                                               const struct AranyaDeviceId *device,
                                               struct AranyaExtError *__ext_err);

/**
 * Add the peer for automatic periodic Aranya state syncing.
 *
 * If a peer is not reachable on the network, sync errors
 * will appear in the tracing logs and
 * Aranya will be unable to sync state with that peer.
 *
 * @param client the Aranya Client [`AranyaClient`](@ref AranyaClient).
 * @param team the team's ID [`AranyaTeamId`](@ref AranyaTeamId).
 * @param addr the peer's Aranya network address [`AranyaAddr`](@ref AranyaAddr).
 * @param config configuration values for syncing with a peer.
 *
 * @relates AranyaClient.
 */
AranyaError aranya_add_sync_peer(struct AranyaClient *client,
                                 const struct AranyaTeamId *team,
                                 AranyaAddr addr,
                                 const struct AranyaSyncPeerConfig *config);

/**
 * Add the peer for automatic periodic Aranya state syncing.
 *
 * If a peer is not reachable on the network, sync errors
 * will appear in the tracing logs and
 * Aranya will be unable to sync state with that peer.
 *
 * @param client the Aranya Client [`AranyaClient`](@ref AranyaClient).
 * @param team the team's ID [`AranyaTeamId`](@ref AranyaTeamId).
 * @param addr the peer's Aranya network address [`AranyaAddr`](@ref AranyaAddr).
 * @param config configuration values for syncing with a peer.
 *
 * @relates AranyaClient.
 */
AranyaError aranya_add_sync_peer_ext(struct AranyaClient *client,
                                     const struct AranyaTeamId *team,
                                     AranyaAddr addr,
                                     const struct AranyaSyncPeerConfig *config,
                                     struct AranyaExtError *__ext_err);

/**
 * Remove the peer from automatic Aranya state syncing.
 *
 * @param client the Aranya Client [`AranyaClient`](@ref AranyaClient).
 * @param team the team's ID [`AranyaTeamId`](@ref AranyaTeamId).
 * @param addr the peer's Aranya network address [`AranyaAddr`](@ref AranyaAddr).
 *
 * @relates AranyaClient.
 */
AranyaError aranya_remove_sync_peer(struct AranyaClient *client,
                                    const struct AranyaTeamId *team,
                                    AranyaAddr addr);

/**
 * Remove the peer from automatic Aranya state syncing.
 *
 * @param client the Aranya Client [`AranyaClient`](@ref AranyaClient).
 * @param team the team's ID [`AranyaTeamId`](@ref AranyaTeamId).
 * @param addr the peer's Aranya network address [`AranyaAddr`](@ref AranyaAddr).
 *
 * @relates AranyaClient.
 */
AranyaError aranya_remove_sync_peer_ext(struct AranyaClient *client,
                                        const struct AranyaTeamId *team,
                                        AranyaAddr addr,
                                        struct AranyaExtError *__ext_err);

/**
 * Sync with peer immediately.
 *
 * If a peer is not reachable on the network, sync errors
 * will appear in the tracing logs and
 * Aranya will be unable to sync state with that peer.
 *
 *
 * This function ignores [`aranya_sync_peer_config_builder_set_interval`](@ref aranya_sync_peer_config_builder_set_interval) and
 * [`aranya_sync_peer_config_builder_set_sync_later`](@ref aranya_sync_peer_config_builder_set_sync_later), if set.
 *
 * @param client the Aranya Client [`AranyaClient`](@ref AranyaClient).
 * @param team the team's ID [`AranyaTeamId`](@ref AranyaTeamId).
 * @param addr the peer's Aranya network address [`AranyaAddr`](@ref AranyaAddr).
 * @param config configuration values for syncing with a peer.
 * Default values for a sync config will be used if `config` is `NULL`
 * @relates AranyaClient.
 */
AranyaError aranya_sync_now(struct AranyaClient *client,
                            const struct AranyaTeamId *team,
                            AranyaAddr addr,
                            const struct AranyaSyncPeerConfig *config);

/**
 * Sync with peer immediately.
 *
 * If a peer is not reachable on the network, sync errors
 * will appear in the tracing logs and
 * Aranya will be unable to sync state with that peer.
 *
 *
 * This function ignores [`aranya_sync_peer_config_builder_set_interval`](@ref aranya_sync_peer_config_builder_set_interval) and
 * [`aranya_sync_peer_config_builder_set_sync_later`](@ref aranya_sync_peer_config_builder_set_sync_later), if set.
 *
 * @param client the Aranya Client [`AranyaClient`](@ref AranyaClient).
 * @param team the team's ID [`AranyaTeamId`](@ref AranyaTeamId).
 * @param addr the peer's Aranya network address [`AranyaAddr`](@ref AranyaAddr).
 * @param config configuration values for syncing with a peer.
 * Default values for a sync config will be used if `config` is `NULL`
 * @relates AranyaClient.
 */
AranyaError aranya_sync_now_ext(struct AranyaClient *client,
                                const struct AranyaTeamId *team,
                                AranyaAddr addr,
                                const struct AranyaSyncPeerConfig *config,
                                struct AranyaExtError *__ext_err);

/**
 * Query devices on team.
 *
 * @param client the Aranya Client [`AranyaClient`](@ref AranyaClient).
 * @param team the team's ID [`AranyaTeamId`](@ref AranyaTeamId).
 * @param devices returns a list of device IDs on the team [`AranyaDeviceId`](@ref AranyaDeviceId).
 * @param devices_len returns the length of the devices list [`AranyaDeviceId`](@ref AranyaDeviceId).
 *
 * @relates AranyaClient.
 */
AranyaError aranya_query_devices_on_team(struct AranyaClient *client,
                                         const struct AranyaTeamId *team,
                                         struct AranyaDeviceId *devices,
                                         size_t *devices_len);

/**
 * Query devices on team.
 *
 * @param client the Aranya Client [`AranyaClient`](@ref AranyaClient).
 * @param team the team's ID [`AranyaTeamId`](@ref AranyaTeamId).
 * @param devices returns a list of device IDs on the team [`AranyaDeviceId`](@ref AranyaDeviceId).
 * @param devices_len returns the length of the devices list [`AranyaDeviceId`](@ref AranyaDeviceId).
 *
 * @relates AranyaClient.
 */
AranyaError aranya_query_devices_on_team_ext(struct AranyaClient *client,
                                             const struct AranyaTeamId *team,
                                             struct AranyaDeviceId *devices,
                                             size_t *devices_len,
                                             struct AranyaExtError *__ext_err);

/**
 * Query device's keybundle.
 *
 * @param client the Aranya Client [`AranyaClient`](@ref AranyaClient).
 * @param team the team's ID [`AranyaTeamId`](@ref AranyaTeamId).
 * @param device the device's ID [`AranyaDeviceId`](@ref AranyaDeviceId).
 * @param keybundle keybundle byte buffer `KeyBundle`.
 * @param keybundle_len returns the length of the serialized keybundle.
 *
 * @relates AranyaClient.
 */
AranyaError aranya_query_device_keybundle(struct AranyaClient *client,
                                          const struct AranyaTeamId *team,
                                          const struct AranyaDeviceId *device,
                                          uint8_t *keybundle,
                                          size_t *keybundle_len);

/**
 * Query device's keybundle.
 *
 * @param client the Aranya Client [`AranyaClient`](@ref AranyaClient).
 * @param team the team's ID [`AranyaTeamId`](@ref AranyaTeamId).
 * @param device the device's ID [`AranyaDeviceId`](@ref AranyaDeviceId).
 * @param keybundle keybundle byte buffer `KeyBundle`.
 * @param keybundle_len returns the length of the serialized keybundle.
 *
 * @relates AranyaClient.
 */
AranyaError aranya_query_device_keybundle_ext(struct AranyaClient *client,
                                              const struct AranyaTeamId *team,
                                              const struct AranyaDeviceId *device,
                                              uint8_t *keybundle,
                                              size_t *keybundle_len,
                                              struct AranyaExtError *__ext_err);

/**
 * Query device label assignments.
 *
 * Returns an `AranyaBufferTooSmall` error if the output buffer is too small to hold the labels.
 * Writes the number of labels that would have been returned to `labels_len`.
 * The application can use `labels_len` to allocate a larger buffer.
 *
 * @param client the Aranya Client [`AranyaClient`](@ref AranyaClient).
 * @param team the team's ID [`AranyaTeamId`](@ref AranyaTeamId).
 * @param device the device's ID [`AranyaDeviceId`](@ref AranyaDeviceId).
 *
 * Output params:
 * @param labels returns a list of labels assigned to the device [`AranyaLabelId`](@ref AranyaLabelId).
 * @param labels_len returns the length of the labels list [`AranyaLabelId`](@ref AranyaLabelId).
 *
 * @relates AranyaClient.
 */
AranyaError aranya_query_device_label_assignments(struct AranyaClient *client,
                                                  const struct AranyaTeamId *team,
                                                  const struct AranyaDeviceId *device,
                                                  struct AranyaLabelId *labels,
                                                  size_t *labels_len);

/**
 * Query device label assignments.
 *
 * Returns an `AranyaBufferTooSmall` error if the output buffer is too small to hold the labels.
 * Writes the number of labels that would have been returned to `labels_len`.
 * The application can use `labels_len` to allocate a larger buffer.
 *
 * @param client the Aranya Client [`AranyaClient`](@ref AranyaClient).
 * @param team the team's ID [`AranyaTeamId`](@ref AranyaTeamId).
 * @param device the device's ID [`AranyaDeviceId`](@ref AranyaDeviceId).
 *
 * Output params:
 * @param labels returns a list of labels assigned to the device [`AranyaLabelId`](@ref AranyaLabelId).
 * @param labels_len returns the length of the labels list [`AranyaLabelId`](@ref AranyaLabelId).
 *
 * @relates AranyaClient.
 */
AranyaError aranya_query_device_label_assignments_ext(struct AranyaClient *client,
                                                      const struct AranyaTeamId *team,
                                                      const struct AranyaDeviceId *device,
                                                      struct AranyaLabelId *labels,
                                                      size_t *labels_len,
                                                      struct AranyaExtError *__ext_err);

/**
 * Query for list of existing labels.
 *
 * Returns an `AranyaBufferTooSmall` error if the output buffer is too small to hold the labels.
 * Writes the number of labels that would have been returned to `labels_len`.
 * The application can use `labels_len` to allocate a larger buffer.
 *
 * @param client the Aranya Client [`AranyaClient`](@ref AranyaClient).
 * @param team the team's ID [`AranyaTeamId`](@ref AranyaTeamId).
 *
 * Output params:
 * @param labels returns a list of labels [`AranyaLabelId`](@ref AranyaLabelId).
 * @param labels_len returns the length of the labels list [`AranyaLabelId`](@ref AranyaLabelId).
 *
 * @relates AranyaClient.
 */
AranyaError aranya_query_labels(struct AranyaClient *client,
                                const struct AranyaTeamId *team,
                                struct AranyaLabelId *labels,
                                size_t *labels_len);

/**
 * Query for list of existing labels.
 *
 * Returns an `AranyaBufferTooSmall` error if the output buffer is too small to hold the labels.
 * Writes the number of labels that would have been returned to `labels_len`.
 * The application can use `labels_len` to allocate a larger buffer.
 *
 * @param client the Aranya Client [`AranyaClient`](@ref AranyaClient).
 * @param team the team's ID [`AranyaTeamId`](@ref AranyaTeamId).
 *
 * Output params:
 * @param labels returns a list of labels [`AranyaLabelId`](@ref AranyaLabelId).
 * @param labels_len returns the length of the labels list [`AranyaLabelId`](@ref AranyaLabelId).
 *
 * @relates AranyaClient.
 */
AranyaError aranya_query_labels_ext(struct AranyaClient *client,
                                    const struct AranyaTeamId *team,
                                    struct AranyaLabelId *labels,
                                    size_t *labels_len,
                                    struct AranyaExtError *__ext_err);

/**
 * Query if a label exists.
 *
 * @param client the Aranya Client [`AranyaClient`](@ref AranyaClient).
 * @param team the team's ID [`AranyaTeamId`](@ref AranyaTeamId).
 * @param device the device's ID [`AranyaDeviceId`](@ref AranyaDeviceId).
 * @param label the label [`AranyaLabelId`](@ref AranyaLabelId).
 * @param __output boolean indicating whether the label exists.
 *
 * @relates AranyaClient.
 */
AranyaError aranya_query_label_exists(struct AranyaClient *client,
                                      const struct AranyaTeamId *team,
                                      const struct AranyaLabelId *label,
                                      bool *__output);

/**
 * Query if a label exists.
 *
 * @param client the Aranya Client [`AranyaClient`](@ref AranyaClient).
 * @param team the team's ID [`AranyaTeamId`](@ref AranyaTeamId).
 * @param device the device's ID [`AranyaDeviceId`](@ref AranyaDeviceId).
 * @param label the label [`AranyaLabelId`](@ref AranyaLabelId).
 * @param __output boolean indicating whether the label exists.
 *
 * @relates AranyaClient.
 */
AranyaError aranya_query_label_exists_ext(struct AranyaClient *client,
                                          const struct AranyaTeamId *team,
                                          const struct AranyaLabelId *label,
                                          bool *__output,
                                          struct AranyaExtError *__ext_err);

/**
 * Query device's AQC network identifier.
 *
 * @param client the Aranya Client [`AranyaClient`](@ref AranyaClient).
 * @param team the team's ID [`AranyaTeamId`](@ref AranyaTeamId).
 * @param device the device's ID [`AranyaDeviceId`](@ref AranyaDeviceId).
 * @param network identifier string [`AranyaNetIdentifier`](@ref AranyaNetIdentifier).
 *
 * @relates AranyaClient.
 */
AranyaError aranya_query_aqc_net_identifier(struct AranyaClient *client,
                                            const struct AranyaTeamId *team,
                                            const struct AranyaDeviceId *device,
                                            char *ident,
                                            size_t *ident_len,
                                            bool *__output);

/**
 * Query device's AQC network identifier.
 *
 * @param client the Aranya Client [`AranyaClient`](@ref AranyaClient).
 * @param team the team's ID [`AranyaTeamId`](@ref AranyaTeamId).
 * @param device the device's ID [`AranyaDeviceId`](@ref AranyaDeviceId).
 * @param network identifier string [`AranyaNetIdentifier`](@ref AranyaNetIdentifier).
 *
 * @relates AranyaClient.
 */
AranyaError aranya_query_aqc_net_identifier_ext(struct AranyaClient *client,
                                                const struct AranyaTeamId *team,
                                                const struct AranyaDeviceId *device,
                                                char *ident,
                                                size_t *ident_len,
                                                bool *__output,
                                                struct AranyaExtError *__ext_err);

/**
 * Associate a network identifier to a device for use with AQC.
 *
 * Permission to perform this operation is checked against the Aranya policy.
 *
 * If the address already exists for this device, it is replaced with the new address. Capable
 * of resolving addresses via DNS, required to be statically mapped to IPV4. For use with
 * OpenChannel and receiving messages. Can take either DNS name or IPV4.
 *
 * @param client the Aranya Client [`AranyaClient`](@ref AranyaClient).
 * @param team the team's ID [`AranyaTeamId`](@ref AranyaTeamId).
 * @param device the device's ID [`AranyaDeviceId`](@ref AranyaDeviceId).
 * @param net_identifier the device's network identifier [`AranyaNetIdentifier`](@ref AranyaNetIdentifier).
 *
 * @relates AranyaClient.
 */
AranyaError aranya_aqc_assign_net_identifier(struct AranyaClient *client,
                                             const struct AranyaTeamId *team,
                                             const struct AranyaDeviceId *device,
                                             AranyaNetIdentifier net_identifier);

/**
 * Associate a network identifier to a device for use with AQC.
 *
 * Permission to perform this operation is checked against the Aranya policy.
 *
 * If the address already exists for this device, it is replaced with the new address. Capable
 * of resolving addresses via DNS, required to be statically mapped to IPV4. For use with
 * OpenChannel and receiving messages. Can take either DNS name or IPV4.
 *
 * @param client the Aranya Client [`AranyaClient`](@ref AranyaClient).
 * @param team the team's ID [`AranyaTeamId`](@ref AranyaTeamId).
 * @param device the device's ID [`AranyaDeviceId`](@ref AranyaDeviceId).
 * @param net_identifier the device's network identifier [`AranyaNetIdentifier`](@ref AranyaNetIdentifier).
 *
 * @relates AranyaClient.
 */
AranyaError aranya_aqc_assign_net_identifier_ext(struct AranyaClient *client,
                                                 const struct AranyaTeamId *team,
                                                 const struct AranyaDeviceId *device,
                                                 AranyaNetIdentifier net_identifier,
                                                 struct AranyaExtError *__ext_err);

/**
 * Disassociate an AQC network identifier from a device.
 *
 * Permission to perform this operation is checked against the Aranya policy.
 *
 * @param client the Aranya Client [`AranyaClient`](@ref AranyaClient).
 * @param team the team's ID [`AranyaTeamId`](@ref AranyaTeamId).
 * @param device the device's ID [`AranyaDeviceId`](@ref AranyaDeviceId).
 * @param net_identifier the device's network identifier [`AranyaNetIdentifier`](@ref AranyaNetIdentifier).
 *
 * @relates AranyaClient.
 */
AranyaError aranya_aqc_remove_net_identifier(struct AranyaClient *client,
                                             const struct AranyaTeamId *team,
                                             const struct AranyaDeviceId *device,
                                             AranyaNetIdentifier net_identifier);

/**
 * Disassociate an AQC network identifier from a device.
 *
 * Permission to perform this operation is checked against the Aranya policy.
 *
 * @param client the Aranya Client [`AranyaClient`](@ref AranyaClient).
 * @param team the team's ID [`AranyaTeamId`](@ref AranyaTeamId).
 * @param device the device's ID [`AranyaDeviceId`](@ref AranyaDeviceId).
 * @param net_identifier the device's network identifier [`AranyaNetIdentifier`](@ref AranyaNetIdentifier).
 *
 * @relates AranyaClient.
 */
AranyaError aranya_aqc_remove_net_identifier_ext(struct AranyaClient *client,
                                                 const struct AranyaTeamId *team,
                                                 const struct AranyaDeviceId *device,
                                                 AranyaNetIdentifier net_identifier,
                                                 struct AranyaExtError *__ext_err);

/**
 * Releases any resources associated with `ptr`.
 *
 * `ptr` must either be null or initialized by `::aranya_aqc_peer_channel_init`.
 *
 * @relates AranyaAqcPeerChannel
 */
AranyaError aranya_aqc_peer_channel_cleanup(struct AranyaAqcPeerChannel *ptr);

/**
 * Releases any resources associated with `ptr`.
 *
 * `ptr` must either be null or initialized by `::aranya_aqc_peer_channel_init`.
 *
 * @relates AranyaAqcPeerChannel
 */
AranyaError aranya_aqc_peer_channel_cleanup_ext(struct AranyaAqcPeerChannel *ptr,
                                                struct AranyaExtError *__ext_err);

/**
 * Releases any resources associated with `ptr`.
 *
 * `ptr` must either be null or initialized by `::aranya_aqc_bidi_channel_init`.
 *
 * @relates AranyaAqcBidiChannel
 */
AranyaError aranya_aqc_bidi_channel_cleanup(struct AranyaAqcBidiChannel *ptr);

/**
 * Releases any resources associated with `ptr`.
 *
 * `ptr` must either be null or initialized by `::aranya_aqc_bidi_channel_init`.
 *
 * @relates AranyaAqcBidiChannel
 */
AranyaError aranya_aqc_bidi_channel_cleanup_ext(struct AranyaAqcBidiChannel *ptr,
                                                struct AranyaExtError *__ext_err);

/**
 * Releases any resources associated with `ptr`.
 *
 * `ptr` must either be null or initialized by `::aranya_aqc_send_channel_init`.
 *
 * @relates AranyaAqcSendChannel
 */
AranyaError aranya_aqc_send_channel_cleanup(struct AranyaAqcSendChannel *ptr);

/**
 * Releases any resources associated with `ptr`.
 *
 * `ptr` must either be null or initialized by `::aranya_aqc_send_channel_init`.
 *
 * @relates AranyaAqcSendChannel
 */
AranyaError aranya_aqc_send_channel_cleanup_ext(struct AranyaAqcSendChannel *ptr,
                                                struct AranyaExtError *__ext_err);

/**
 * Releases any resources associated with `ptr`.
 *
 * `ptr` must either be null or initialized by `::aranya_aqc_receive_channel_init`.
 *
 * @relates AranyaAqcReceiveChannel
 */
AranyaError aranya_aqc_receive_channel_cleanup(struct AranyaAqcReceiveChannel *ptr);

/**
 * Releases any resources associated with `ptr`.
 *
 * `ptr` must either be null or initialized by `::aranya_aqc_receive_channel_init`.
 *
 * @relates AranyaAqcReceiveChannel
 */
AranyaError aranya_aqc_receive_channel_cleanup_ext(struct AranyaAqcReceiveChannel *ptr,
                                                   struct AranyaExtError *__ext_err);

/**
 * Releases any resources associated with `ptr`.
 *
 * `ptr` must either be null or initialized by `::aranya_aqc_bidi_stream_init`.
 *
 * @relates AranyaAqcBidiStream
 */
AranyaError aranya_aqc_bidi_stream_cleanup(struct AranyaAqcBidiStream *ptr);

/**
 * Releases any resources associated with `ptr`.
 *
 * `ptr` must either be null or initialized by `::aranya_aqc_bidi_stream_init`.
 *
 * @relates AranyaAqcBidiStream
 */
AranyaError aranya_aqc_bidi_stream_cleanup_ext(struct AranyaAqcBidiStream *ptr,
                                               struct AranyaExtError *__ext_err);

/**
 * Releases any resources associated with `ptr`.
 *
 * `ptr` must either be null or initialized by `::aranya_aqc_send_stream_init`.
 *
 * @relates AranyaAqcSendStream
 */
AranyaError aranya_aqc_send_stream_cleanup(struct AranyaAqcSendStream *ptr);

/**
 * Releases any resources associated with `ptr`.
 *
 * `ptr` must either be null or initialized by `::aranya_aqc_send_stream_init`.
 *
 * @relates AranyaAqcSendStream
 */
AranyaError aranya_aqc_send_stream_cleanup_ext(struct AranyaAqcSendStream *ptr,
                                               struct AranyaExtError *__ext_err);

/**
 * Releases any resources associated with `ptr`.
 *
 * `ptr` must either be null or initialized by `::aranya_aqc_receive_stream_init`.
 *
 * @relates AranyaAqcReceiveStream
 */
AranyaError aranya_aqc_receive_stream_cleanup(struct AranyaAqcReceiveStream *ptr);

/**
 * Releases any resources associated with `ptr`.
 *
 * `ptr` must either be null or initialized by `::aranya_aqc_receive_stream_init`.
 *
 * @relates AranyaAqcReceiveStream
 */
AranyaError aranya_aqc_receive_stream_cleanup_ext(struct AranyaAqcReceiveStream *ptr,
                                                  struct AranyaExtError *__ext_err);

/**
 * Create a bidirectional AQC channel between this device and a peer.
 *
 * Permission to perform this operation is checked against the Aranya policy.
 *
 * @param[in]  client the Aranya Client [`AranyaClient`](@ref AranyaClient).
 * @param[in]  team the team's ID [`AranyaTeamId`](@ref AranyaTeamId).
 * @param[in]  peer the peer's network identifier [`AranyaNetIdentifier`](@ref AranyaNetIdentifier).
 * @param[in]  label_id the AQC channel label ID [`AranyaLabelId`](@ref AranyaLabelId) to create the channel with.
 * @param[out] channel the AQC channel object [`AranyaAqcBidiChannel`](@ref AranyaAqcBidiChannel).
 *
 * @relates AranyaClient.
 */
AranyaError aranya_aqc_create_bidi_channel(struct AranyaClient *client,
                                           const struct AranyaTeamId *team,
                                           AranyaNetIdentifier peer,
                                           const struct AranyaLabelId *label_id,
                                           struct AranyaAqcBidiChannel *channel);

/**
 * Create a bidirectional AQC channel between this device and a peer.
 *
 * Permission to perform this operation is checked against the Aranya policy.
 *
 * @param[in]  client the Aranya Client [`AranyaClient`](@ref AranyaClient).
 * @param[in]  team the team's ID [`AranyaTeamId`](@ref AranyaTeamId).
 * @param[in]  peer the peer's network identifier [`AranyaNetIdentifier`](@ref AranyaNetIdentifier).
 * @param[in]  label_id the AQC channel label ID [`AranyaLabelId`](@ref AranyaLabelId) to create the channel with.
 * @param[out] channel the AQC channel object [`AranyaAqcBidiChannel`](@ref AranyaAqcBidiChannel).
 *
 * @relates AranyaClient.
 */
AranyaError aranya_aqc_create_bidi_channel_ext(struct AranyaClient *client,
                                               const struct AranyaTeamId *team,
                                               AranyaNetIdentifier peer,
                                               const struct AranyaLabelId *label_id,
                                               struct AranyaAqcBidiChannel *channel,
                                               struct AranyaExtError *__ext_err);

/**
 * Create a unidirectional AQC channel between this device and a peer.
 *
 * Permission to perform this operation is checked against the Aranya policy.
 *
 * @param[in]  client the Aranya Client [`AranyaClient`](@ref AranyaClient).
 * @param[in]  team the team's ID [`AranyaTeamId`](@ref AranyaTeamId).
 * @param[in]  peer the peer's network identifier [`AranyaNetIdentifier`](@ref AranyaNetIdentifier).
 * @param[in]  label_id the AQC channel label ID [`AranyaLabelId`](@ref AranyaLabelId) to create the channel with.
 * @param[out] channel the AQC channel object [`AranyaAqcSendChannel`](@ref AranyaAqcSendChannel).
 *
 * @relates AranyaClient.
 */
AranyaError aranya_aqc_create_uni_channel(struct AranyaClient *client,
                                          const struct AranyaTeamId *team,
                                          AranyaNetIdentifier peer,
                                          const struct AranyaLabelId *label_id,
                                          struct AranyaAqcSendChannel *channel);

/**
 * Create a unidirectional AQC channel between this device and a peer.
 *
 * Permission to perform this operation is checked against the Aranya policy.
 *
 * @param[in]  client the Aranya Client [`AranyaClient`](@ref AranyaClient).
 * @param[in]  team the team's ID [`AranyaTeamId`](@ref AranyaTeamId).
 * @param[in]  peer the peer's network identifier [`AranyaNetIdentifier`](@ref AranyaNetIdentifier).
 * @param[in]  label_id the AQC channel label ID [`AranyaLabelId`](@ref AranyaLabelId) to create the channel with.
 * @param[out] channel the AQC channel object [`AranyaAqcSendChannel`](@ref AranyaAqcSendChannel).
 *
 * @relates AranyaClient.
 */
AranyaError aranya_aqc_create_uni_channel_ext(struct AranyaClient *client,
                                              const struct AranyaTeamId *team,
                                              AranyaNetIdentifier peer,
                                              const struct AranyaLabelId *label_id,
                                              struct AranyaAqcSendChannel *channel,
                                              struct AranyaExtError *__ext_err);

/**
 * Delete a bidirectional AQC channel.
 *
 * Note that this function takes ownership of the [`AranyaAqcBidiChannel`](@ref AranyaAqcBidiChannel) and invalidates any further use.
 *
 * @param[in] client the Aranya Client [`AranyaClient`](@ref AranyaClient).
 * @param[in] channel the AQC Channel [`AranyaAqcBidiChannel`](@ref AranyaAqcBidiChannel) to delete.
 *
 * @relates AranyaClient.
 */
AranyaError aranya_aqc_delete_bidi_channel(struct AranyaClient *client,
                                           struct AranyaAqcBidiChannel *channel);

/**
 * Delete a bidirectional AQC channel.
 *
 * Note that this function takes ownership of the [`AranyaAqcBidiChannel`](@ref AranyaAqcBidiChannel) and invalidates any further use.
 *
 * @param[in] client the Aranya Client [`AranyaClient`](@ref AranyaClient).
 * @param[in] channel the AQC Channel [`AranyaAqcBidiChannel`](@ref AranyaAqcBidiChannel) to delete.
 *
 * @relates AranyaClient.
 */
AranyaError aranya_aqc_delete_bidi_channel_ext(struct AranyaClient *client,
                                               struct AranyaAqcBidiChannel *channel,
                                               struct AranyaExtError *__ext_err);

/**
 * Delete a unidirectional AQC channel.
 *
 * Note that this function takes ownership of the [`AranyaAqcSendChannel`](@ref AranyaAqcSendChannel) and invalidates any further use.
 *
 * @param[in] client the Aranya Client [`AranyaClient`](@ref AranyaClient).
 * @param[in] channel the AQC Channel [`AranyaAqcSendChannel`](@ref AranyaAqcSendChannel) to delete.
 *
 * @relates AranyaClient.
 */
AranyaError aranya_aqc_delete_uni_channel(struct AranyaClient *client,
                                          struct AranyaAqcSendChannel *channel);

/**
 * Delete a unidirectional AQC channel.
 *
 * Note that this function takes ownership of the [`AranyaAqcSendChannel`](@ref AranyaAqcSendChannel) and invalidates any further use.
 *
 * @param[in] client the Aranya Client [`AranyaClient`](@ref AranyaClient).
 * @param[in] channel the AQC Channel [`AranyaAqcSendChannel`](@ref AranyaAqcSendChannel) to delete.
 *
 * @relates AranyaClient.
 */
AranyaError aranya_aqc_delete_uni_channel_ext(struct AranyaClient *client,
                                              struct AranyaAqcSendChannel *channel,
                                              struct AranyaExtError *__ext_err);

/**
 * Tries to poll AQC to see if any channels have been received.
 *
 * This can return `ARANYA_ERROR_WOULD_BLOCK` to signal that there aren't any
 * channels received yet which is considered a non-fatal error.
 *
 * Note that the [`AranyaAqcPeerChannel`](@ref AranyaAqcPeerChannel) must be converted before it can be used:
 * ```C
 * AranyaAqcPeerChannel channel;
 * AranyaAqcChannelType channel_type;
 * AranyaAqcBidiChannel bidi;
 * AranyaAqcReceiveChannel receiver;
 *
 * aranya_aqc_try_receive_channel(&client, &channel, &channel_type);
 * switch (channel_type) {
 *     case ARANYA_AQC_CHANNEL_TYPE_BIDIRECTIONAL:
 *         aranya_aqc_get_bidi_channel(&channel, &bidi);
 *         break;
 *     case ARANYA_AQC_CHANNEL_TYPE_RECEIVER:
 *         aranya_aqc_get_receive_channel(&channel, &receiver);
 *         break;
 * }
 * ```
 *
 * @param[in]  client the Aranya Client [`AranyaClient`](@ref AranyaClient).
 * @param[out] channel the AQC channel holder [`AranyaAqcPeerChannel`](@ref AranyaAqcPeerChannel).
 * @param[out] __output the corresponding AQC channel type [`AranyaAqcChannelType`](@ref AranyaAqcChannelType).
 *
 * @relates AranyaClient.
 */
AranyaError aranya_aqc_try_receive_channel(struct AranyaClient *client,
                                           struct AranyaAqcPeerChannel *channel,
                                           AranyaAqcChannelType *__output);

/**
 * Tries to poll AQC to see if any channels have been received.
 *
 * This can return `ARANYA_ERROR_WOULD_BLOCK` to signal that there aren't any
 * channels received yet which is considered a non-fatal error.
 *
 * Note that the [`AranyaAqcPeerChannel`](@ref AranyaAqcPeerChannel) must be converted before it can be used:
 * ```C
 * AranyaAqcPeerChannel channel;
 * AranyaAqcChannelType channel_type;
 * AranyaAqcBidiChannel bidi;
 * AranyaAqcReceiveChannel receiver;
 *
 * aranya_aqc_try_receive_channel(&client, &channel, &channel_type);
 * switch (channel_type) {
 *     case ARANYA_AQC_CHANNEL_TYPE_BIDIRECTIONAL:
 *         aranya_aqc_get_bidi_channel(&channel, &bidi);
 *         break;
 *     case ARANYA_AQC_CHANNEL_TYPE_RECEIVER:
 *         aranya_aqc_get_receive_channel(&channel, &receiver);
 *         break;
 * }
 * ```
 *
 * @param[in]  client the Aranya Client [`AranyaClient`](@ref AranyaClient).
 * @param[out] channel the AQC channel holder [`AranyaAqcPeerChannel`](@ref AranyaAqcPeerChannel).
 * @param[out] __output the corresponding AQC channel type [`AranyaAqcChannelType`](@ref AranyaAqcChannelType).
 *
 * @relates AranyaClient.
 */
AranyaError aranya_aqc_try_receive_channel_ext(struct AranyaClient *client,
                                               struct AranyaAqcPeerChannel *channel,
                                               AranyaAqcChannelType *__output,
                                               struct AranyaExtError *__ext_err);

/**
 * Converts the [`AranyaAqcPeerChannel`](@ref AranyaAqcPeerChannel)` into an [`AranyaAqcBidiChannel`](@ref AranyaAqcBidiChannel) for sending/receiving data.
 *
 * Returns `ARANYA_ERROR_INVALID_ARGUMENT` if called when the AqcPeerChannel is the wrong type.
 *
 * Note that this function takes ownership of the [`AranyaAqcPeerChannel`](@ref AranyaAqcPeerChannel) and invalidates any further use.
 *
 * @param[in]  channel the AQC channel holder [`AranyaAqcPeerChannel`](@ref AranyaAqcPeerChannel) that holds a channel object.
 * @param[out] bidi the AQC channel object [`AranyaAqcBidiChannel`](@ref AranyaAqcBidiChannel) that holds channel info.
 *
 * @relates AranyaClient.
 */
AranyaError aranya_aqc_get_bidi_channel(struct AranyaAqcPeerChannel *channel,
                                        struct AranyaAqcBidiChannel *bidi);

/**
 * Converts the [`AranyaAqcPeerChannel`](@ref AranyaAqcPeerChannel)` into an [`AranyaAqcBidiChannel`](@ref AranyaAqcBidiChannel) for sending/receiving data.
 *
 * Returns `ARANYA_ERROR_INVALID_ARGUMENT` if called when the AqcPeerChannel is the wrong type.
 *
 * Note that this function takes ownership of the [`AranyaAqcPeerChannel`](@ref AranyaAqcPeerChannel) and invalidates any further use.
 *
 * @param[in]  channel the AQC channel holder [`AranyaAqcPeerChannel`](@ref AranyaAqcPeerChannel) that holds a channel object.
 * @param[out] bidi the AQC channel object [`AranyaAqcBidiChannel`](@ref AranyaAqcBidiChannel) that holds channel info.
 *
 * @relates AranyaClient.
 */
AranyaError aranya_aqc_get_bidi_channel_ext(struct AranyaAqcPeerChannel *channel,
                                            struct AranyaAqcBidiChannel *bidi,
                                            struct AranyaExtError *__ext_err);

/**
 * Converts the [`AranyaAqcPeerChannel`](@ref AranyaAqcPeerChannel)` into an [`AranyaAqcReceiveChannel`](@ref AranyaAqcReceiveChannel) for receiving data.
 *
 * Returns `ARANYA_ERROR_INVALID_ARGUMENT` if called when the AqcPeerChannel is the wrong type.
 *
 * Note that this function takes ownership of the [`AranyaAqcPeerChannel`](@ref AranyaAqcPeerChannel) and invalidates any further use.
 *
 * @param[in]  channel the AQC channel container [`AranyaAqcPeerChannel`](@ref AranyaAqcPeerChannel).
 * @param[out] receiver the AQC channel object [`AranyaAqcReceiveChannel`](@ref AranyaAqcReceiveChannel).
 *
 * @relates AranyaClient.
 */
AranyaError aranya_aqc_get_receive_channel(struct AranyaAqcPeerChannel *channel,
                                           struct AranyaAqcReceiveChannel *receiver);

/**
 * Converts the [`AranyaAqcPeerChannel`](@ref AranyaAqcPeerChannel)` into an [`AranyaAqcReceiveChannel`](@ref AranyaAqcReceiveChannel) for receiving data.
 *
 * Returns `ARANYA_ERROR_INVALID_ARGUMENT` if called when the AqcPeerChannel is the wrong type.
 *
 * Note that this function takes ownership of the [`AranyaAqcPeerChannel`](@ref AranyaAqcPeerChannel) and invalidates any further use.
 *
 * @param[in]  channel the AQC channel container [`AranyaAqcPeerChannel`](@ref AranyaAqcPeerChannel).
 * @param[out] receiver the AQC channel object [`AranyaAqcReceiveChannel`](@ref AranyaAqcReceiveChannel).
 *
 * @relates AranyaClient.
 */
AranyaError aranya_aqc_get_receive_channel_ext(struct AranyaAqcPeerChannel *channel,
                                               struct AranyaAqcReceiveChannel *receiver,
                                               struct AranyaExtError *__ext_err);

/**
 * Create a bidirectional stream from a [`AranyaAqcBidiChannel`](@ref AranyaAqcBidiChannel).
 *
 * Note that the recipient will not be able to receive the stream until data is
 * sent over the stream.
 *
 * @param[in]  client the Aranya Client [`AranyaClient`](@ref AranyaClient).
 * @param[in]  channel the AQC channel object [`AranyaAqcBidiChannel`](@ref AranyaAqcBidiChannel).
 * @param[out] stream the bidirectional AQC stream [`AranyaAqcBidiStream`](@ref AranyaAqcBidiStream).
 *
 * @relates AranyaClient.
 */
AranyaError aranya_aqc_bidi_create_bidi_stream(struct AranyaClient *client,
                                               struct AranyaAqcBidiChannel *channel,
                                               struct AranyaAqcBidiStream *stream);

/**
 * Create a bidirectional stream from a [`AranyaAqcBidiChannel`](@ref AranyaAqcBidiChannel).
 *
 * Note that the recipient will not be able to receive the stream until data is
 * sent over the stream.
 *
 * @param[in]  client the Aranya Client [`AranyaClient`](@ref AranyaClient).
 * @param[in]  channel the AQC channel object [`AranyaAqcBidiChannel`](@ref AranyaAqcBidiChannel).
 * @param[out] stream the bidirectional AQC stream [`AranyaAqcBidiStream`](@ref AranyaAqcBidiStream).
 *
 * @relates AranyaClient.
 */
AranyaError aranya_aqc_bidi_create_bidi_stream_ext(struct AranyaClient *client,
                                                   struct AranyaAqcBidiChannel *channel,
                                                   struct AranyaAqcBidiStream *stream,
                                                   struct AranyaExtError *__ext_err);

/**
 * Send some data to a peer using an [`AranyaAqcBidiStream`](@ref AranyaAqcBidiStream).
 *
 * @param[in] client the Aranya Client [`AranyaClient`](@ref AranyaClient).
 * @param[in] stream the sending side of a stream [`AranyaAqcBidiStream`](@ref AranyaAqcBidiStream).
 * @param[in] data pointer to the data to send.
 * @param[in] data_len length of the data to send.
 *
 * @relates AranyaClient.
 */
AranyaError aranya_aqc_bidi_stream_send(struct AranyaClient *client,
                                        struct AranyaAqcBidiStream *stream,
                                        const uint8_t *data,
                                        size_t data_len);

/**
 * Send some data to a peer using an [`AranyaAqcBidiStream`](@ref AranyaAqcBidiStream).
 *
 * @param[in] client the Aranya Client [`AranyaClient`](@ref AranyaClient).
 * @param[in] stream the sending side of a stream [`AranyaAqcBidiStream`](@ref AranyaAqcBidiStream).
 * @param[in] data pointer to the data to send.
 * @param[in] data_len length of the data to send.
 *
 * @relates AranyaClient.
 */
AranyaError aranya_aqc_bidi_stream_send_ext(struct AranyaClient *client,
                                            struct AranyaAqcBidiStream *stream,
                                            const uint8_t *data,
                                            size_t data_len,
                                            struct AranyaExtError *__ext_err);

/**
 * Receive some data from an [`AranyaAqcBidiStream`](@ref AranyaAqcBidiStream).
 *
 * This can return `ARANYA_ERROR_WOULD_BLOCK` to signal that there aren't any streams
 * received yet which is considered a non-fatal error.
 *
 * @param[in]  stream the receiving side of a stream [`AranyaAqcBidiStream`](@ref AranyaAqcBidiStream).
 * @param[out] buffer pointer to the target buffer.
 * @param[in] buffer_len length of the target buffer.
 * @param[out] __output the number of bytes written to the buffer.
 *
 * @relates AranyaClient.
 */
AranyaError aranya_aqc_bidi_stream_try_recv(struct AranyaAqcBidiStream *stream,
                                            uint8_t *buffer,
                                            size_t buffer_len,
                                            size_t *__output);

/**
 * Receive some data from an [`AranyaAqcBidiStream`](@ref AranyaAqcBidiStream).
 *
 * This can return `ARANYA_ERROR_WOULD_BLOCK` to signal that there aren't any streams
 * received yet which is considered a non-fatal error.
 *
 * @param[in]  stream the receiving side of a stream [`AranyaAqcBidiStream`](@ref AranyaAqcBidiStream).
 * @param[out] buffer pointer to the target buffer.
 * @param[in] buffer_len length of the target buffer.
 * @param[out] __output the number of bytes written to the buffer.
 *
 * @relates AranyaClient.
 */
AranyaError aranya_aqc_bidi_stream_try_recv_ext(struct AranyaAqcBidiStream *stream,
                                                uint8_t *buffer,
                                                size_t buffer_len,
                                                size_t *__output,
                                                struct AranyaExtError *__ext_err);

/**
 * Create a unidirectional stream from an [`AranyaAqcBidiChannel`](@ref AranyaAqcBidiChannel).
 *
 * Note that the recipient will not be able to receive the stream until data is
 * sent over the stream.
 *
 * @param[in]  client the Aranya Client [`AranyaClient`](@ref AranyaClient).
 * @param[in]  channel the AQC channel object [`AranyaAqcBidiChannel`](@ref AranyaAqcBidiChannel).
 * @param[out] stream the sending side of a stream [`AranyaAqcSendStream`](@ref AranyaAqcSendStream).
 *
 * @relates AranyaClient.
 */
AranyaError aranya_aqc_bidi_create_uni_stream(struct AranyaClient *client,
                                              struct AranyaAqcBidiChannel *channel,
                                              struct AranyaAqcSendStream *stream);

/**
 * Create a unidirectional stream from an [`AranyaAqcBidiChannel`](@ref AranyaAqcBidiChannel).
 *
 * Note that the recipient will not be able to receive the stream until data is
 * sent over the stream.
 *
 * @param[in]  client the Aranya Client [`AranyaClient`](@ref AranyaClient).
 * @param[in]  channel the AQC channel object [`AranyaAqcBidiChannel`](@ref AranyaAqcBidiChannel).
 * @param[out] stream the sending side of a stream [`AranyaAqcSendStream`](@ref AranyaAqcSendStream).
 *
 * @relates AranyaClient.
 */
AranyaError aranya_aqc_bidi_create_uni_stream_ext(struct AranyaClient *client,
                                                  struct AranyaAqcBidiChannel *channel,
                                                  struct AranyaAqcSendStream *stream,
                                                  struct AranyaExtError *__ext_err);

/**
 * Tries to receive the receive (and potentially send) ends of a stream.
 *
 * This can return `ARANYA_ERROR_WOULD_BLOCK` to signal that there aren't any
 * streams received yet which is considered a non-fatal error.
 *
 * Note that the recipient will not be able to receive the stream until data is
 * sent over the stream.
 *
 * Additionally, the send stream will only be initialized if `send_init` is true.
 *
 * @param[in]  channel the AQC channel object [`AranyaAqcBidiChannel`](@ref AranyaAqcBidiChannel).
 * @param[out] recv_stream the receiving side of a stream [`AranyaAqcReceiveStream`](@ref AranyaAqcReceiveStream).
 * @param[out] send_stream the sending side of a stream [`AranyaAqcSendStream`](@ref AranyaAqcSendStream).
 * @param[out] send_init whether or not we received a `send_stream`.
 *
 * @relates AranyaClient.
 */
AranyaError aranya_aqc_bidi_try_receive_stream(struct AranyaAqcBidiChannel *channel,
                                               struct AranyaAqcReceiveStream *recv_stream,
                                               struct AranyaAqcSendStream *send_stream,
                                               bool *send_init);

/**
 * Tries to receive the receive (and potentially send) ends of a stream.
 *
 * This can return `ARANYA_ERROR_WOULD_BLOCK` to signal that there aren't any
 * streams received yet which is considered a non-fatal error.
 *
 * Note that the recipient will not be able to receive the stream until data is
 * sent over the stream.
 *
 * Additionally, the send stream will only be initialized if `send_init` is true.
 *
 * @param[in]  channel the AQC channel object [`AranyaAqcBidiChannel`](@ref AranyaAqcBidiChannel).
 * @param[out] recv_stream the receiving side of a stream [`AranyaAqcReceiveStream`](@ref AranyaAqcReceiveStream).
 * @param[out] send_stream the sending side of a stream [`AranyaAqcSendStream`](@ref AranyaAqcSendStream).
 * @param[out] send_init whether or not we received a `send_stream`.
 *
 * @relates AranyaClient.
 */
AranyaError aranya_aqc_bidi_try_receive_stream_ext(struct AranyaAqcBidiChannel *channel,
                                                   struct AranyaAqcReceiveStream *recv_stream,
                                                   struct AranyaAqcSendStream *send_stream,
                                                   bool *send_init,
                                                   struct AranyaExtError *__ext_err);

/**
 * Create a unidirectional stream from an [`AranyaAqcSendChannel`](@ref AranyaAqcSendChannel).
 *
 * Note that the recipient will not be able to receive the stream until data is
 * sent over the stream.
 *
 * @param[in]  client the Aranya Client [`AranyaClient`](@ref AranyaClient).
 * @param[in]  channel the AQC channel object [`AranyaAqcSendChannel`](@ref AranyaAqcSendChannel).
 * @param[out] stream the sending side of a stream [`AranyaAqcSendStream`](@ref AranyaAqcSendStream).
 *
 * @relates AranyaClient.
 */
AranyaError aranya_aqc_send_create_uni_stream(struct AranyaClient *client,
                                              struct AranyaAqcSendChannel *channel,
                                              struct AranyaAqcSendStream *stream);

/**
 * Create a unidirectional stream from an [`AranyaAqcSendChannel`](@ref AranyaAqcSendChannel).
 *
 * Note that the recipient will not be able to receive the stream until data is
 * sent over the stream.
 *
 * @param[in]  client the Aranya Client [`AranyaClient`](@ref AranyaClient).
 * @param[in]  channel the AQC channel object [`AranyaAqcSendChannel`](@ref AranyaAqcSendChannel).
 * @param[out] stream the sending side of a stream [`AranyaAqcSendStream`](@ref AranyaAqcSendStream).
 *
 * @relates AranyaClient.
 */
AranyaError aranya_aqc_send_create_uni_stream_ext(struct AranyaClient *client,
                                                  struct AranyaAqcSendChannel *channel,
                                                  struct AranyaAqcSendStream *stream,
                                                  struct AranyaExtError *__ext_err);

/**
 * Receives the stream from an [`AranyaAqcReceiveChannel`](@ref AranyaAqcReceiveChannel).
 *
 * Note that the recipient will not be able to receive the stream until data is
 * sent over the stream.
 *
 * This can return `ARANYA_ERROR_WOULD_BLOCK` to signal that there aren't any streams
 * received yet which is considered a non-fatal error.
 *
 * @param[in]  channel the AQC channel object [`AranyaAqcReceiveChannel`](@ref AranyaAqcReceiveChannel).
 * @param[out] stream the receiving side of a stream [`AranyaAqcReceiveStream`](@ref AranyaAqcReceiveStream).
 *
 * @relates AranyaClient.
 */
AranyaError aranya_aqc_recv_try_receive_uni_stream(struct AranyaAqcReceiveChannel *channel,
                                                   struct AranyaAqcReceiveStream *stream);

/**
 * Receives the stream from an [`AranyaAqcReceiveChannel`](@ref AranyaAqcReceiveChannel).
 *
 * Note that the recipient will not be able to receive the stream until data is
 * sent over the stream.
 *
 * This can return `ARANYA_ERROR_WOULD_BLOCK` to signal that there aren't any streams
 * received yet which is considered a non-fatal error.
 *
 * @param[in]  channel the AQC channel object [`AranyaAqcReceiveChannel`](@ref AranyaAqcReceiveChannel).
 * @param[out] stream the receiving side of a stream [`AranyaAqcReceiveStream`](@ref AranyaAqcReceiveStream).
 *
 * @relates AranyaClient.
 */
AranyaError aranya_aqc_recv_try_receive_uni_stream_ext(struct AranyaAqcReceiveChannel *channel,
                                                       struct AranyaAqcReceiveStream *stream,
                                                       struct AranyaExtError *__ext_err);

/**
 * Send some data over an [`AranyaAqcSendStream`](@ref AranyaAqcSendStream)m.
 *
 * @param[in] client the Aranya Client [`AranyaClient`](@ref AranyaClient).
 * @param[in] stream the sending side of a stream [`AranyaAqcSendStream`](@ref AranyaAqcSendStream).
 * @param[in] data pointer to the data to send.
 * @param[in] data_len length of the data to send.
 *
 * @relates AranyaClient.
 */
AranyaError aranya_aqc_send_stream_send(struct AranyaClient *client,
                                        struct AranyaAqcSendStream *stream,
                                        const uint8_t *data,
                                        size_t data_len);

/**
 * Send some data over an [`AranyaAqcSendStream`](@ref AranyaAqcSendStream)m.
 *
 * @param[in] client the Aranya Client [`AranyaClient`](@ref AranyaClient).
 * @param[in] stream the sending side of a stream [`AranyaAqcSendStream`](@ref AranyaAqcSendStream).
 * @param[in] data pointer to the data to send.
 * @param[in] data_len length of the data to send.
 *
 * @relates AranyaClient.
 */
AranyaError aranya_aqc_send_stream_send_ext(struct AranyaClient *client,
                                            struct AranyaAqcSendStream *stream,
                                            const uint8_t *data,
                                            size_t data_len,
                                            struct AranyaExtError *__ext_err);

/**
 * Receive some data from an [`AranyaAqcReceiveStream`](@ref AranyaAqcReceiveStream).
 *
 * This can return `ARANYA_ERROR_WOULD_BLOCK` to signal that there aren't any streams
 * received yet which is considered a non-fatal error.
 *
 * @param[in]  stream the receiving side of a stream [`AranyaAqcReceiveStream`](@ref AranyaAqcReceiveStream).
 * @param[out] buffer pointer to the target buffer.
 * @param[in] buffer_len length of the target buffer.
 * @param[out] __output the number of bytes written to the buffer.
 *
 * @relates AranyaClient.
 */
AranyaError aranya_aqc_recv_stream_try_recv(struct AranyaAqcReceiveStream *stream,
                                            uint8_t *buffer,
                                            size_t buffer_len,
                                            size_t *__output);

/**
 * Receive some data from an [`AranyaAqcReceiveStream`](@ref AranyaAqcReceiveStream).
 *
 * This can return `ARANYA_ERROR_WOULD_BLOCK` to signal that there aren't any streams
 * received yet which is considered a non-fatal error.
 *
 * @param[in]  stream the receiving side of a stream [`AranyaAqcReceiveStream`](@ref AranyaAqcReceiveStream).
 * @param[out] buffer pointer to the target buffer.
 * @param[in] buffer_len length of the target buffer.
 * @param[out] __output the number of bytes written to the buffer.
 *
 * @relates AranyaClient.
 */
AranyaError aranya_aqc_recv_stream_try_recv_ext(struct AranyaAqcReceiveStream *stream,
                                                uint8_t *buffer,
                                                size_t buffer_len,
                                                size_t *__output,
                                                struct AranyaExtError *__ext_err);

#ifdef __cplusplus
}  // extern "C"
#endif  // __cplusplus

#endif  /* ARANYA_CLIENT_H */


