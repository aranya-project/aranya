// clang-format off
// This header is @generated by cbindgen.

/*
 * Copyright (c) SpiderOak, Inc. All rights reserved.
 */
/**
 * @file aranya-client.h
 * @brief External header file containing C function definitions
 * for the Aranya client library.
 */
 

#ifndef ARANYA_CLIENT_H
#define ARANYA_CLIENT_H

#pragma once

/* Code generated by `capi`. DO NOT EDIT. */

#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <sys/socket.h>

#ifndef __has_attribute
    #define __has_attribute(x) 0
#endif /* __has_attribute */

#if !defined(ARANYA_ALIGNED)
    #if __has_attribute(aligned)
        #define ARANYA_ALIGNED(n) __attribute__((aligned(n)))
    #else
        #error "compiler must support `aligned` attribute"
    #endif
#endif /* ARANYA_ALIGNED */

#if !defined(ARANYA_DESIGNATED_INIT)
    #if __has_attribute(designated_init)
        #define ARANYA_DESIGNATED_INIT __attribute__((designated_init))
    #else
        #define ARANYA_DESIGNATED_INIT
    #endif
#endif /* ARANYA_DESIGNATED_INIT */

#if !defined(ARANYA_MUST_USE)
    #if __has_attribute(warn_unused_result)
        #define ARANYA_MUST_USE __attribute__((warn_unused_result))
    #else
        #define ARANYA_MUST_USE
    #endif
#endif /* ARANYA_MUST_USE */

#if !defined(ARANYA_NO_RETURN)
    #if __has_attribute(noreturn)
        #define ARANYA_NO_RETURN __attribute__((noreturn))
    #else
        #define ARANYA_NO_RETURN
    #endif
#endif /* ARANYA_NO_RETURN */

#if !defined(ARANYA_NON_NULL)
    #if defined(__gnu__)
        #if __has_attribute(nonnull)
            #define ARANYA_NON_NULL __attribute__((nonnull))
        #endif
    #elif defined(__clang__)
        #define ARANYA_NON_NULL _Nonnull
    #else
        #define ARANYA_NON_NULL
    #endif
#endif /* ARANYA_NON_NULL */

#if !defined(ARANYA_PACKED)
    #if __has_attribute(packed)
        #define ARANYA_PACKED __attribute__((packed))
    #else
        #define ARANYA_PACKED
    #endif
#endif /* ARANYA_PACKED */


#define ARANYA_DURATION_SECONDS (1000 * ARANYA_DURATION_MILLISECONDS)

#define ARANYA_DURATION_MILLISECONDS (1000 * ARANYA_DURATION_MICROSECONDS)

#define ARANYA_DURATION_MICROSECONDS (1000 * ARANYA_DURATION_NANOSECONDS)

#define ARANYA_DURATION_NANOSECONDS 1

/**
 * The size in bytes of an ID
 */
#define ARANYA_ID_LEN 32

/**
 * The number of roles returned from `setup_default_roles`.
 */
#define DEFAULT_ROLES_LEN 3

/**
 * The size in bytes of a PSK seed IKM.
 */
#define ARANYA_SEED_IKM_LEN 32

/**
 * The size in bytes of an ID converted to a human-readable base58 string.
 */
#define ARANYA_ID_STR_LEN (((ARANYA_ID_LEN * 1375) / 1000) + 1)

#if defined(ENABLE_ARANYA_AFC)
/**
 * The overhead needed for a channel message.
 *
 * Note that the ciphertext buffer must be at least `plaintext_len` +
 * `aranya_afc_channel_overhead()` long.
 */
#define ARANYA_AFC_CHANNEL_OVERHEAD 24
#endif

/**
 * An error code.
 *
 * For extended error information, see [`AranyaExtError`](@ref AranyaExtError).
 */
enum AranyaError
#ifdef __cplusplus
  : uint32_t
#endif // __cplusplus
 {
    /**
     * Success.
     */
    ARANYA_ERROR_SUCCESS,
    /**
     * Internal bug discovered.
     */
    ARANYA_ERROR_BUG,
    /**
     * Timed out.
     */
    ARANYA_ERROR_TIMEOUT,
    /**
     * Invalid argument.
     */
    ARANYA_ERROR_INVALID_ARGUMENT,
    /**
     * Component is not enabled.
     */
    ARANYA_ERROR_NOT_ENABLED,
    /**
     * Buffer is too small.
     */
    ARANYA_ERROR_BUFFER_TOO_SMALL,
    /**
     * Invalid UTF-8.
     */
    ARANYA_ERROR_INVALID_UTF8,
    /**
     * Invalid Address.
     */
    ARANYA_ERROR_INVALID_ADDR,
    /**
     * Could not send request to daemon.
     */
    ARANYA_ERROR_IPC,
    /**
     * An Aranya error.
     */
    ARANYA_ERROR_ARANYA,
#if defined(ENABLE_ARANYA_AFC)
    ARANYA_ERROR_WRONG_CHANNEL_TYPE,
#endif
    /**
     * Tried to poll an endpoint but nothing received yet.
     */
    ARANYA_ERROR_WOULD_BLOCK,
    /**
     * A connection got unexpectedly closed.
     */
    ARANYA_ERROR_CLOSED,
    /**
     * Unable to create configuration info.
     */
    ARANYA_ERROR_CONFIG,
    /**
     * Serialization error.
     */
    ARANYA_ERROR_SERIALIZATION,
    /**
     * Some other error occurred.
     */
    ARANYA_ERROR_OTHER,
};
#ifndef __cplusplus
typedef uint32_t AranyaError;
#endif // __cplusplus

#if defined(ENABLE_ARANYA_PREVIEW)
/**
 * Role management permission.
 */
enum AranyaRoleManagementPermission
#ifdef __cplusplus
  : uint8_t
#endif // __cplusplus
 {
    /**
     * Grants a managing role the ability to assign the target role
     * to any device except itself.
     */
    ARANYA_ROLE_MANAGEMENT_PERMISSION_CAN_ASSIGN_ROLE,
    /**
     * Grants a managing role the ability to revoke the target role
     * from any device.
     */
    ARANYA_ROLE_MANAGEMENT_PERMISSION_CAN_REVOKE_ROLE,
    /**
     * Grants a managing role the ability to change the permissions
     * assigned to the target role.
     */
    ARANYA_ROLE_MANAGEMENT_PERMISSION_CAN_CHANGE_ROLE_PERMS,
};
#ifndef __cplusplus
typedef uint8_t AranyaRoleManagementPermission;
#endif // __cplusplus
#endif

#if defined(ENABLE_ARANYA_PREVIEW)
/**
 * Simple permission.
 */
enum AranyaPermission
#ifdef __cplusplus
  : uint8_t
#endif // __cplusplus
 {
    /**
     * The role can add a device to the team.
     */
    ARANYA_PERMISSION_ADD_DEVICE,
    /**
     * The role can remove a device from the team.
     */
    ARANYA_PERMISSION_REMOVE_DEVICE,
    /**
     * The role can terminate the team. This causes all team
     * commands to fail until a new team is created.
     */
    ARANYA_PERMISSION_TERMINATE_TEAM,
    /**
     * The role can create a role.
     */
    ARANYA_PERMISSION_CREATE_ROLE,
    /**
     * The role can delete a role.
     */
    ARANYA_PERMISSION_DELETE_ROLE,
    /**
     * The role can assign a role to other devices.
     */
    ARANYA_PERMISSION_ASSIGN_ROLE,
    /**
     * The role can revoke a role from other devices.
     */
    ARANYA_PERMISSION_REVOKE_ROLE,
    /**
     * The role can change role management permissions for roles.
     */
    ARANYA_PERMISSION_CHANGE_ROLE_MANAGEMENT_PERMS,
    /**
     * The role can set up default roles. This can only be done
     * once, so this permission can only effectively be used by
     * the `owner` role.
     */
    ARANYA_PERMISSION_SETUP_DEFAULT_ROLE,
    /**
     * The role can add a managing role to or remove a managing
     * role from a target role.
     */
    ARANYA_PERMISSION_CHANGE_ROLE_MANAGING_ROLE,
    /**
     * The role can create a label.
     */
    ARANYA_PERMISSION_CREATE_LABEL,
    /**
     * The role can delete a label.
     */
    ARANYA_PERMISSION_DELETE_LABEL,
    /**
     * The role can grant a target role the ability to manage a
     * label. This management ability includes deleting a label
     * and adding/revoking a label to a device.
     */
    ARANYA_PERMISSION_CHANGE_LABEL_MANAGING_ROLE,
    /**
     * The role can assign a label to a device. The role must
     * also have label management permissions granted by a role
     * with the `ChangeLabelManagingRole` permission above.
     */
    ARANYA_PERMISSION_ASSIGN_LABEL,
    /**
     * The role can revoke a label from a device. The role must
     * also have label management permissions granted by a role
     * with the `ChangeLabelManagingRole` permission above.
     */
    ARANYA_PERMISSION_REVOKE_LABEL,
    /**
     * The role can use AFC. This controls the ability to
     * create or receive a unidirectional AFC channels.
     */
    ARANYA_PERMISSION_CAN_USE_AFC,
    /**
     * The role can create a unidirectional AFC channel.
     */
    ARANYA_PERMISSION_CREATE_AFC_UNI_CHANNEL,
};
#ifndef __cplusplus
typedef uint8_t AranyaPermission;
#endif // __cplusplus
#endif

/**
 * Valid channel operations for a label assignment.
 */
enum AranyaChanOp
#ifdef __cplusplus
  : uint8_t
#endif // __cplusplus
 {
    /**
     * The device can only receive data in channels with this
     * label.
     */
    ARANYA_CHAN_OP_RECV_ONLY,
    /**
     * The device can only send data in channels with this
     * label.
     */
    ARANYA_CHAN_OP_SEND_ONLY,
    /**
     * The device can send or receive data in channels with this
     * label.
     */
    ARANYA_CHAN_OP_SEND_RECV,
};
#ifndef __cplusplus
typedef uint8_t AranyaChanOp;
#endif // __cplusplus

/**
 * Functions suffixed with `_ext` accept an extra
 * `struct AranyaExtError *ext_err` parameter for extended error information.
 *
 * - `ext_err` must be a valid, non-NULL pointer.
 * - If the call returns anything other than `ARANYA_ERROR_SUCCESS`,
 *   `*ext_err` is populated with additional error details.
 * - On success, the content of `ext_err` is unchanged.
 * - To extract a human-readable message:
 *       \code{.c}
 *       AranyaError aranya_ext_error_msg(
 *           const struct AranyaExtError *err,
 *           char *msg,
 *           size_t *msg_len
 *       );
 *         \endcode
 *
 * Example:
 *     \code{.c}
 *     struct AranyaExtError ext_err;
 *     AranyaError rc = aranya_get_device_id_ext(client, &id, &ext_err);
 *     if (rc != ARANYA_ERROR_SUCCESS) {
 *         size_t len = 0;
 *         aranya_ext_error_msg(&ext_err, NULL, &len);
 *         char *buf = malloc(len);
 *         aranya_ext_error_msg(&ext_err, buf, &len);
 *         // `buf` now holds the detailed error message
 *     }
 *     \endcode
 */
typedef struct ARANYA_ALIGNED(8) AranyaExtError {
    /**
     * This field only exists for size purposes. It is
     * UNDEFINED BEHAVIOR to read from or write to it.
     * @private
     */
    uint8_t __for_size_only[96];
} AranyaExtError;

/**
 * A handle to an Aranya Client.
 */
typedef struct ARANYA_ALIGNED(16) AranyaClient {
    /**
     * This field only exists for size purposes. It is
     * UNDEFINED BEHAVIOR to read from or write to it.
     * @private
     */
    uint8_t __for_size_only[3728];
} AranyaClient;

/**
 * Configuration info for Aranya.
 *
 * Use a [`AranyaClientConfigBuilder`](@ref AranyaClientConfigBuilder) to construct this object.
 */
typedef struct ARANYA_ALIGNED(8) AranyaClientConfig {
    /**
     * This field only exists for size purposes. It is
     * UNDEFINED BEHAVIOR to read from or write to it.
     * @private
     */
    uint8_t __for_size_only[56];
} AranyaClientConfig;

/**
 * A role.
 */
typedef struct ARANYA_ALIGNED(8) AranyaRole {
    /**
     * This field only exists for size purposes. It is
     * UNDEFINED BEHAVIOR to read from or write to it.
     * @private
     */
    uint8_t __for_size_only[112];
} AranyaRole;

/**
 * Cryptographically secure Aranya ID.
 */
typedef struct AranyaId {
    uint8_t bytes[ARANYA_ID_LEN];
} AranyaId;

/**
 * Uniquely identifies a [`AranyaRole`](@ref AranyaRole).
 */
typedef struct AranyaRoleId {
    struct AranyaId id;
} AranyaRoleId;

/**
 * Device ID.
 */
typedef struct AranyaDeviceId {
    struct AranyaId id;
} AranyaDeviceId;

/**
 * Configuration info builder for an Aranya client config [`AranyaClientConfig`](@ref AranyaClientConfig).
 */
typedef struct ARANYA_ALIGNED(8) AranyaClientConfigBuilder {
    /**
     * This field only exists for size purposes. It is
     * UNDEFINED BEHAVIOR to read from or write to it.
     * @private
     */
    uint8_t __for_size_only[72];
} AranyaClientConfigBuilder;

/**
 * A type to represent a span of time in nanoseconds.
 */
typedef uint64_t AranyaDuration;

/**
 * A builder for initializing an [`AranyaAddTeamQuicSyncConfig`](@ref AranyaAddTeamQuicSyncConfig).
 *
 * The [`AranyaAddTeamQuicSyncConfig`](@ref AranyaAddTeamQuicSyncConfig) is an optional part of initializing an [`AranyaAddTeamConfig`](@ref AranyaAddTeamConfig).
 */
typedef struct ARANYA_ALIGNED(8) AranyaAddTeamQuicSyncConfigBuilder {
    /**
     * This field only exists for size purposes. It is
     * UNDEFINED BEHAVIOR to read from or write to it.
     * @private
     */
    uint8_t __for_size_only[288];
} AranyaAddTeamQuicSyncConfigBuilder;

/**
 * A builder for initializing a [`AranyaCreateTeamQuicSyncConfig`](@ref AranyaCreateTeamQuicSyncConfig).
 *
 * The [`AranyaCreateTeamQuicSyncConfig`](@ref AranyaCreateTeamQuicSyncConfig) is an optional part of initializing a [`AranyaCreateTeamConfig`](@ref AranyaCreateTeamConfig).
 */
typedef struct ARANYA_ALIGNED(8) AranyaCreateTeamQuicSyncConfigBuilder {
    /**
     * This field only exists for size purposes. It is
     * UNDEFINED BEHAVIOR to read from or write to it.
     * @private
     */
    uint8_t __for_size_only[56];
} AranyaCreateTeamQuicSyncConfigBuilder;

/**
 * Raw PSK seed IKM for QUIC syncer.
 */
typedef struct AranyaSeedIkm {
    uint8_t bytes[ARANYA_SEED_IKM_LEN];
} AranyaSeedIkm;

/**
 * QUIC syncer configuration.
 *
 * Use a [`AranyaCreateTeamQuicSyncConfigBuilder`](@ref AranyaCreateTeamQuicSyncConfigBuilder) to construct this object.
 */
typedef struct ARANYA_ALIGNED(8) AranyaCreateTeamQuicSyncConfig {
    /**
     * This field only exists for size purposes. It is
     * UNDEFINED BEHAVIOR to read from or write to it.
     * @private
     */
    uint8_t __for_size_only[56];
} AranyaCreateTeamQuicSyncConfig;

/**
 * QUIC syncer configuration.
 *
 * Use an [`AranyaAddTeamQuicSyncConfigBuilder`](@ref AranyaAddTeamQuicSyncConfigBuilder) to construct this object.
 */
typedef struct ARANYA_ALIGNED(8) AranyaAddTeamQuicSyncConfig {
    /**
     * This field only exists for size purposes. It is
     * UNDEFINED BEHAVIOR to read from or write to it.
     * @private
     */
    uint8_t __for_size_only[288];
} AranyaAddTeamQuicSyncConfig;

/**
 * A builder for initializing an [`AranyaAddTeamConfig`](@ref AranyaAddTeamConfig).
 */
typedef struct ARANYA_ALIGNED(8) AranyaAddTeamConfigBuilder {
    /**
     * This field only exists for size purposes. It is
     * UNDEFINED BEHAVIOR to read from or write to it.
     * @private
     */
    uint8_t __for_size_only[328];
} AranyaAddTeamConfigBuilder;

/**
 * A builder for initializing a [`AranyaCreateTeamConfig`](@ref AranyaCreateTeamConfig).
 */
typedef struct ARANYA_ALIGNED(8) AranyaCreateTeamConfigBuilder {
    /**
     * This field only exists for size purposes. It is
     * UNDEFINED BEHAVIOR to read from or write to it.
     * @private
     */
    uint8_t __for_size_only[56];
} AranyaCreateTeamConfigBuilder;

/**
 * Team ID.
 */
typedef struct AranyaTeamId {
    struct AranyaId id;
} AranyaTeamId;

/**
 * Team configuration used when joining a team.
 *
 * Use an [`AranyaAddTeamConfigBuilder`](@ref AranyaAddTeamConfigBuilder) to construct this object.
 */
typedef struct ARANYA_ALIGNED(8) AranyaAddTeamConfig {
    /**
     * This field only exists for size purposes. It is
     * UNDEFINED BEHAVIOR to read from or write to it.
     * @private
     */
    uint8_t __for_size_only[320];
} AranyaAddTeamConfig;

/**
 * Team configuration used when creating a team.
 *
 * Use a [`AranyaCreateTeamConfigBuilder`](@ref AranyaCreateTeamConfigBuilder) to construct this object.
 */
typedef struct ARANYA_ALIGNED(8) AranyaCreateTeamConfig {
    /**
     * This field only exists for size purposes. It is
     * UNDEFINED BEHAVIOR to read from or write to it.
     * @private
     */
    uint8_t __for_size_only[56];
} AranyaCreateTeamConfig;

/**
 * Builder for a Sync Peer config [`AranyaSyncPeerConfig`](@ref AranyaSyncPeerConfig).
 */
typedef struct ARANYA_ALIGNED(8) AranyaSyncPeerConfigBuilder {
    /**
     * This field only exists for size purposes. It is
     * UNDEFINED BEHAVIOR to read from or write to it.
     * @private
     */
    uint8_t __for_size_only[40];
} AranyaSyncPeerConfigBuilder;

/**
 * Sync Peer config.
 *
 * Use a [`AranyaSyncPeerConfigBuilder`](@ref AranyaSyncPeerConfigBuilder) to construct this object.
 */
typedef struct ARANYA_ALIGNED(8) AranyaSyncPeerConfig {
    /**
     * This field only exists for size purposes. It is
     * UNDEFINED BEHAVIOR to read from or write to it.
     * @private
     */
    uint8_t __for_size_only[40];
} AranyaSyncPeerConfig;

/**
 * A role name.
 *
 * E.g. "owner"
 */
typedef const char *AranyaRoleName;

/**
 * A label name.
 *
 * E.g. "TELEMETRY_LABEL"
 */
typedef const char *AranyaLabelName;

/**
 * Label ID.
 */
typedef struct AranyaLabelId {
    struct AranyaId id;
} AranyaLabelId;

/**
 * A network socket address for an Aranya client.
 *
 * E.g. "localhost:8080", "127.0.0.1:8080"
 */
typedef const char *AranyaAddr;

#if defined(ENABLE_ARANYA_AFC)
/**
 * An AFC Sending Channel Object.
 */
typedef struct ARANYA_ALIGNED(8) AranyaAfcSendChannel {
    /**
     * This field only exists for size purposes. It is
     * UNDEFINED BEHAVIOR to read from or write to it.
     * @private
     */
    uint8_t __for_size_only[160];
} AranyaAfcSendChannel;
#endif

#if defined(ENABLE_ARANYA_AFC)
/**
 * An AFC Receiving Channel Object.
 */
typedef struct ARANYA_ALIGNED(8) AranyaAfcReceiveChannel {
    /**
     * This field only exists for size purposes. It is
     * UNDEFINED BEHAVIOR to read from or write to it.
     * @private
     */
    uint8_t __for_size_only[160];
} AranyaAfcReceiveChannel;
#endif

#if defined(ENABLE_ARANYA_AFC)
/**
 * An AFC Control Message, used to create the other end of a channel.
 *
 * In order to access the underlying buffer to send to a peer, you'll need to
 * call `aranya_afc_ctrl_msg_get_bytes()`.
 */
typedef struct ARANYA_ALIGNED(8) AranyaAfcCtrlMsg {
    /**
     * This field only exists for size purposes. It is
     * UNDEFINED BEHAVIOR to read from or write to it.
     * @private
     */
    uint8_t __for_size_only[32];
} AranyaAfcCtrlMsg;
#endif

#if defined(ENABLE_ARANYA_AFC)
/**
 * An AFC Sequence Number, for reordering messages.
 *
 * You can compare two sequence numbers using `aranya_afc_seq_cmp()`.
 */
typedef struct ARANYA_ALIGNED(8) AranyaAfcSeq {
    /**
     * This field only exists for size purposes. It is
     * UNDEFINED BEHAVIOR to read from or write to it.
     * @private
     */
    uint8_t __for_size_only[24];
} AranyaAfcSeq;
#endif

#if defined(ENABLE_ARANYA_AFC)
/**
 * Channel ID for AFC channel.
 */
typedef struct AranyaAfcChannelId {
    struct AranyaId id;
} AranyaAfcChannelId;
#endif

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

/**
 * Returns a human-readable error message for an [`AranyaError`](@ref AranyaError).
 *
 * The resulting pointer must NOT be freed.
 *
 * @param[in] err `u32` error code from `AranyaError`.
 *
 * @relates AranyaError.
 */
const char *aranya_error_to_str(uint32_t err);

/**
 * Initializes `AranyaExtError`.
 *
 * When no longer needed, `out`'s resources must be released
 * with its cleanup routine.
 *
 * @relates AranyaExtError
 */
AranyaError aranya_ext_error_init(struct AranyaExtError *out);

/**
 * Releases any resources associated with `ptr`.
 *
 * `ptr` must either be null or initialized by `::aranya_ext_error_init`.
 *
 * @relates AranyaExtError
 */
AranyaError aranya_ext_error_cleanup(struct AranyaExtError *ptr);

/**
 * Copies the extended error's message into `msg`.
 *
 * If `msg_len` is large enough to fit the entire message,
 * including the trailing null byte, it updates `msg_len`
 * with the length of the message and copies the message
 * into `msg`.
 *
 * Otherwise, if `msg_len` is not large enough to fit the
 * entire message, including the trailing null byte, it
 * updates `msg_len` with the length of the message and
 * returns `::ARANYA_ERROR_BUFFER_TOO_SMALL`.
 *
 * @param[in] err the error to get a message for.
 * @param[out] msg buffer to copy error message into.
 * @param[in,out] msg_len length of the message buffer.
 *
 * @relates AranyaExtError.
 */
AranyaError aranya_ext_error_msg(const struct AranyaExtError *err,
                                 char *msg,
                                 size_t *msg_len);

/**
 * Copies the extended error's message into `msg`.
 *
 * If `msg_len` is large enough to fit the entire message,
 * including the trailing null byte, it updates `msg_len`
 * with the length of the message and copies the message
 * into `msg`.
 *
 * Otherwise, if `msg_len` is not large enough to fit the
 * entire message, including the trailing null byte, it
 * updates `msg_len` with the length of the message and
 * returns `::ARANYA_ERROR_BUFFER_TOO_SMALL`.
 *
 * @param[in] err the error to get a message for.
 * @param[out] msg buffer to copy error message into.
 * @param[in,out] msg_len length of the message buffer.
 *
 * @relates AranyaExtError.
 */
AranyaError aranya_ext_error_msg_ext(const struct AranyaExtError *err,
                                     char *msg,
                                     size_t *msg_len,
                                     struct AranyaExtError *__ext_err);

/**
 * Initializes a new client instance.
 *
 * @param[out] client the uninitialized Aranya Client
 * @param[in] config the client's configuration
 *
 * @relates AranyaClient.
 */
AranyaError aranya_client_init(struct AranyaClient *client,
                               const struct AranyaClientConfig *config);

/**
 * Initializes a new client instance.
 *
 * @param[out] client the uninitialized Aranya Client
 * @param[in] config the client's configuration
 *
 * @relates AranyaClient.
 */
AranyaError aranya_client_init_ext(struct AranyaClient *client,
                                   const struct AranyaClientConfig *config,
                                   struct AranyaExtError *__ext_err);

/**
 * Releases any resources associated with `ptr`.
 *
 * `ptr` must either be null or initialized by `::aranya_client_init`.
 *
 * @relates AranyaClient
 */
AranyaError aranya_client_cleanup(struct AranyaClient *ptr);

/**
 * Releases any resources associated with `ptr`.
 *
 * `ptr` must either be null or initialized by `::aranya_role_init`.
 *
 * @relates AranyaRole
 */
AranyaError aranya_role_cleanup(struct AranyaRole *ptr);

/**
 * Get ID of role.
 *
 * @param[in] role the role
 *
 * @relates AranyaRole
 */
AranyaError aranya_role_get_id(const struct AranyaRole *role,
                               struct AranyaRoleId *__output);

/**
 * Get ID of role.
 *
 * @param[in] role the role
 *
 * @relates AranyaRole
 */
AranyaError aranya_role_get_id_ext(const struct AranyaRole *role,
                                   struct AranyaRoleId *__output,
                                   struct AranyaExtError *__ext_err);

/**
 * Get name of role.
 *
 * The resulting string must not be freed.
 *
 * @param[in] role the role
 *
 * @relates AranyaRole
 */
AranyaError aranya_role_get_name(const struct AranyaRole *role,
                                 const char **__output);

/**
 * Get the author of a role.
 *
 * @param[in] role the role
 *
 * @relates AranyaRole
 */
AranyaError aranya_role_get_author(const struct AranyaRole *role,
                                   struct AranyaDeviceId *__output);

/**
 * Get the author of a role.
 *
 * @param[in] role the role
 *
 * @relates AranyaRole
 */
AranyaError aranya_role_get_author_ext(const struct AranyaRole *role,
                                       struct AranyaDeviceId *__output,
                                       struct AranyaExtError *__ext_err);

/**
 * Initializes logging.
 *
 * Assumes the `ARANYA_CAPI` environment variable has been set to the desired tracing log level.
 * E.g. `ARANYA_CAPI=debug`.
 */
AranyaError aranya_init_logging(void);

/**
 * Initializes logging.
 *
 * Assumes the `ARANYA_CAPI` environment variable has been set to the desired tracing log level.
 * E.g. `ARANYA_CAPI=debug`.
 */
AranyaError aranya_init_logging_ext(struct AranyaExtError *__ext_err);

/**
 * Gets the public key bundle for this device.
 *
 * @param[in] client the Aranya Client
 * @param[out] keybundle keybundle byte buffer `KeyBundle`.
 * @param[in,out] keybundle_len returns the length of the serialized keybundle.
 *
 * @relates AranyaClient.
 */
AranyaError aranya_get_key_bundle(const struct AranyaClient *client,
                                  uint8_t *keybundle,
                                  size_t *keybundle_len);

/**
 * Gets the public key bundle for this device.
 *
 * @param[in] client the Aranya Client
 * @param[out] keybundle keybundle byte buffer `KeyBundle`.
 * @param[in,out] keybundle_len returns the length of the serialized keybundle.
 *
 * @relates AranyaClient.
 */
AranyaError aranya_get_key_bundle_ext(const struct AranyaClient *client,
                                      uint8_t *keybundle,
                                      size_t *keybundle_len,
                                      struct AranyaExtError *__ext_err);

/**
 * Writes the human-readable encoding of `id` to `str`.
 *
 * To always succeed, `str` must be at least `ARANYA_ID_STR_LEN` bytes long.
 *
 * @param[in] device ID
 * @param[out] str ID string
 * @param[in,out] str_len returns the length of `str`
 *
 * @relates AranyaId.
 */
AranyaError aranya_id_to_str(const struct AranyaId *id,
                             char *str,
                             size_t *str_len);

/**
 * Decodes `str` into an [`AranyaId`](@ref AranyaId).
 *
 * @param[in] str pointer to a null-terminated string.
 *
 * @relates AranyaId.
 */
AranyaError aranya_id_from_str(const char *str, struct AranyaId *__output);

/**
 * Gets the public device ID.
 *
 * @param[in] client the Aranya Client
 * @param[out] __output the client's device ID
 *
 * @relates AranyaClient.
 */
AranyaError aranya_get_device_id(const struct AranyaClient *client,
                                 struct AranyaDeviceId *__output);

/**
 * Gets the public device ID.
 *
 * @param[in] client the Aranya Client
 * @param[out] __output the client's device ID
 *
 * @relates AranyaClient.
 */
AranyaError aranya_get_device_id_ext(const struct AranyaClient *client,
                                     struct AranyaDeviceId *__output,
                                     struct AranyaExtError *__ext_err);

/**
 * Initializes `AranyaClientConfigBuilder`.
 *
 * When no longer needed, `out`'s resources must be released
 * with its cleanup routine.
 *
 * @relates AranyaClientConfigBuilder
 */
AranyaError aranya_client_config_builder_init(struct AranyaClientConfigBuilder *out);

/**
 * Releases any resources associated with `ptr`.
 *
 * `ptr` must either be null or initialized by `::aranya_client_config_builder_init`.
 *
 * @relates AranyaClientConfigBuilder
 */
AranyaError aranya_client_config_builder_cleanup(struct AranyaClientConfigBuilder *ptr);

/**
 * Attempts to construct a [`AranyaClientConfig`](@ref AranyaClientConfig).
 *
 * This function consumes and releases any resources associated
 * with the memory pointed to by `cfg`.
 *
 * @param[in] cfg a pointer to the client config builder
 * @param[out] out a pointer to write the client config to
 *
 * @relates AranyaClientConfigBuilder.
 */
AranyaError aranya_client_config_build(struct AranyaClientConfigBuilder *cfg,
                                       struct AranyaClientConfig *out);

/**
 * Attempts to construct a [`AranyaClientConfig`](@ref AranyaClientConfig).
 *
 * This function consumes and releases any resources associated
 * with the memory pointed to by `cfg`.
 *
 * @param[in] cfg a pointer to the client config builder
 * @param[out] out a pointer to write the client config to
 *
 * @relates AranyaClientConfigBuilder.
 */
AranyaError aranya_client_config_build_ext(struct AranyaClientConfigBuilder *cfg,
                                           struct AranyaClientConfig *out,
                                           struct AranyaExtError *__ext_err);

/**
 * Sets Unix Domain Socket path that the daemon is listening on.
 *
 * @param[in,out] cfg a pointer to the client config builder
 * @param[in] address a string containing the address
 *
 * @relates AranyaClientConfigBuilder.
 */
AranyaError aranya_client_config_builder_set_daemon_uds_path(struct AranyaClientConfigBuilder *cfg,
                                                             const char *address);

/**
 * Sets Unix Domain Socket path that the daemon is listening on.
 *
 * @param[in,out] cfg a pointer to the client config builder
 * @param[in] address a string containing the address
 *
 * @relates AranyaClientConfigBuilder.
 */
AranyaError aranya_client_config_builder_set_daemon_uds_path_ext(struct AranyaClientConfigBuilder *cfg,
                                                                 const char *address,
                                                                 struct AranyaExtError *__ext_err);

/**
 * Sets IPC timeout for `AranyaClient` APIs.
 *
 * By default, the IPC timeout is set to 1 year.
 *
 * @param[in,out] cfg a pointer to the client config builder
 * @param[in] duration the IPC timeout
 *
 * @relates AranyaClientConfigBuilder.
 */
AranyaError aranya_client_config_builder_set_ipc_timeout(struct AranyaClientConfigBuilder *cfg,
                                                         AranyaDuration duration);

/**
 * Sets IPC timeout for `AranyaClient` APIs.
 *
 * By default, the IPC timeout is set to 1 year.
 *
 * @param[in,out] cfg a pointer to the client config builder
 * @param[in] duration the IPC timeout
 *
 * @relates AranyaClientConfigBuilder.
 */
AranyaError aranya_client_config_builder_set_ipc_timeout_ext(struct AranyaClientConfigBuilder *cfg,
                                                             AranyaDuration duration,
                                                             struct AranyaExtError *__ext_err);

/**
 * Initializes `AranyaAddTeamQuicSyncConfigBuilder`.
 *
 * When no longer needed, `out`'s resources must be released
 * with its cleanup routine.
 *
 * @relates AranyaAddTeamQuicSyncConfigBuilder
 */
AranyaError aranya_add_team_quic_sync_config_builder_init(struct AranyaAddTeamQuicSyncConfigBuilder *out);

/**
 * Releases any resources associated with `ptr`.
 *
 * `ptr` must either be null or initialized by `::aranya_add_team_quic_sync_config_builder_init`.
 *
 * @relates AranyaAddTeamQuicSyncConfigBuilder
 */
AranyaError aranya_add_team_quic_sync_config_builder_cleanup(struct AranyaAddTeamQuicSyncConfigBuilder *ptr);

/**
 * Initializes `AranyaCreateTeamQuicSyncConfigBuilder`.
 *
 * When no longer needed, `out`'s resources must be released
 * with its cleanup routine.
 *
 * @relates AranyaCreateTeamQuicSyncConfigBuilder
 */
AranyaError aranya_create_team_quic_sync_config_builder_init(struct AranyaCreateTeamQuicSyncConfigBuilder *out);

/**
 * Releases any resources associated with `ptr`.
 *
 * `ptr` must either be null or initialized by `::aranya_create_team_quic_sync_config_builder_init`.
 *
 * @relates AranyaCreateTeamQuicSyncConfigBuilder
 */
AranyaError aranya_create_team_quic_sync_config_builder_cleanup(struct AranyaCreateTeamQuicSyncConfigBuilder *ptr);

/**
 * Attempts to set PSK seed generation mode value on [`AranyaCreateTeamQuicSyncConfigBuilder`](@ref AranyaCreateTeamQuicSyncConfigBuilder).
 *
 * @param[in,out] cfg a pointer to the quic sync config builder
 *
 * This method will be removed soon since certificates will be used instead of PSKs in the future.
 *
 * @relates AranyaCreateTeamQuicSyncConfigBuilder.
 */
AranyaError aranya_create_team_quic_sync_config_generate(struct AranyaCreateTeamQuicSyncConfigBuilder *cfg);

/**
 * Attempts to set PSK seed generation mode value on [`AranyaCreateTeamQuicSyncConfigBuilder`](@ref AranyaCreateTeamQuicSyncConfigBuilder).
 *
 * @param[in,out] cfg a pointer to the quic sync config builder
 *
 * This method will be removed soon since certificates will be used instead of PSKs in the future.
 *
 * @relates AranyaCreateTeamQuicSyncConfigBuilder.
 */
AranyaError aranya_create_team_quic_sync_config_generate_ext(struct AranyaCreateTeamQuicSyncConfigBuilder *cfg,
                                                             struct AranyaExtError *__ext_err);

/**
 * Attempts to set wrapped PSK seed value on [`AranyaAddTeamQuicSyncConfigBuilder`](@ref AranyaAddTeamQuicSyncConfigBuilder).
 *
 * @param[in,out] cfg a pointer to the quic sync config builder
 * @param[in] encap_seed a pointer the encapsulated PSK seed
 *
 * This method will be removed soon since certificates will be used instead of PSKs in the future.
 *
 * @relates AranyaAddTeamQuicSyncConfigBuilder.
 */
AranyaError aranya_add_team_quic_sync_config_wrapped_seed(struct AranyaAddTeamQuicSyncConfigBuilder *cfg,
                                                          const uint8_t *encap_seed,
                                                          size_t encap_seed_len);

/**
 * Attempts to set wrapped PSK seed value on [`AranyaAddTeamQuicSyncConfigBuilder`](@ref AranyaAddTeamQuicSyncConfigBuilder).
 *
 * @param[in,out] cfg a pointer to the quic sync config builder
 * @param[in] encap_seed a pointer the encapsulated PSK seed
 *
 * This method will be removed soon since certificates will be used instead of PSKs in the future.
 *
 * @relates AranyaAddTeamQuicSyncConfigBuilder.
 */
AranyaError aranya_add_team_quic_sync_config_wrapped_seed_ext(struct AranyaAddTeamQuicSyncConfigBuilder *cfg,
                                                              const uint8_t *encap_seed,
                                                              size_t encap_seed_len,
                                                              struct AranyaExtError *__ext_err);

/**
 * Attempts to set raw PSK seed IKM value [`AranyaSeedIkm`](@ref AranyaSeedIkm) on [`AranyaCreateTeamQuicSyncConfigBuilder`](@ref AranyaCreateTeamQuicSyncConfigBuilder).
 *
 * @param[in,out] cfg a pointer to the quic sync config builder
 * @param[in] ikm a pointer the raw PSK seed IKM
 *
 * This method will be removed soon since certificates will be used instead of PSKs in the future.
 *
 * @relates AranyaCreateTeamQuicSyncConfigBuilder.
 */
AranyaError aranya_create_team_quic_sync_config_raw_seed_ikm(struct AranyaCreateTeamQuicSyncConfigBuilder *cfg,
                                                             const struct AranyaSeedIkm *ikm);

/**
 * Attempts to set raw PSK seed IKM value [`AranyaSeedIkm`](@ref AranyaSeedIkm) on [`AranyaCreateTeamQuicSyncConfigBuilder`](@ref AranyaCreateTeamQuicSyncConfigBuilder).
 *
 * @param[in,out] cfg a pointer to the quic sync config builder
 * @param[in] ikm a pointer the raw PSK seed IKM
 *
 * This method will be removed soon since certificates will be used instead of PSKs in the future.
 *
 * @relates AranyaCreateTeamQuicSyncConfigBuilder.
 */
AranyaError aranya_create_team_quic_sync_config_raw_seed_ikm_ext(struct AranyaCreateTeamQuicSyncConfigBuilder *cfg,
                                                                 const struct AranyaSeedIkm *ikm,
                                                                 struct AranyaExtError *__ext_err);

/**
 * Attempts to set raw PSK seed IKM value [`AranyaSeedIkm`](@ref AranyaSeedIkm) on [`AranyaAddTeamQuicSyncConfigBuilder`](@ref AranyaAddTeamQuicSyncConfigBuilder).
 *
 * @param[in,out] cfg a pointer to the quic sync config builder
 * @param[in] ikm a pointer the raw PSK seed IKM
 *
 * This method will be removed soon since certificates will be used instead of PSKs in the future.
 *
 * @relates AranyaAddTeamQuicSyncConfigBuilder.
 */
AranyaError aranya_add_team_quic_sync_config_raw_seed_ikm(struct AranyaAddTeamQuicSyncConfigBuilder *cfg,
                                                          const struct AranyaSeedIkm *ikm);

/**
 * Attempts to set raw PSK seed IKM value [`AranyaSeedIkm`](@ref AranyaSeedIkm) on [`AranyaAddTeamQuicSyncConfigBuilder`](@ref AranyaAddTeamQuicSyncConfigBuilder).
 *
 * @param[in,out] cfg a pointer to the quic sync config builder
 * @param[in] ikm a pointer the raw PSK seed IKM
 *
 * This method will be removed soon since certificates will be used instead of PSKs in the future.
 *
 * @relates AranyaAddTeamQuicSyncConfigBuilder.
 */
AranyaError aranya_add_team_quic_sync_config_raw_seed_ikm_ext(struct AranyaAddTeamQuicSyncConfigBuilder *cfg,
                                                              const struct AranyaSeedIkm *ikm,
                                                              struct AranyaExtError *__ext_err);

/**
 * Attempts to construct a [`AranyaCreateTeamQuicSyncConfig`](@ref AranyaCreateTeamQuicSyncConfig).
 *
 * This function consumes and releases any resources associated
 * with the memory pointed to by `cfg`.
 *
 * @param[in] cfg a pointer to the QUIC sync config builder
 * @param[out] out a pointer to write the QUIC sync config to
 *
 * @relates AranyaCreateTeamQuicSyncConfigBuilder.
 */
AranyaError aranya_create_team_quic_sync_config_build(struct AranyaCreateTeamQuicSyncConfigBuilder *cfg,
                                                      struct AranyaCreateTeamQuicSyncConfig *out);

/**
 * Attempts to construct a [`AranyaCreateTeamQuicSyncConfig`](@ref AranyaCreateTeamQuicSyncConfig).
 *
 * This function consumes and releases any resources associated
 * with the memory pointed to by `cfg`.
 *
 * @param[in] cfg a pointer to the QUIC sync config builder
 * @param[out] out a pointer to write the QUIC sync config to
 *
 * @relates AranyaCreateTeamQuicSyncConfigBuilder.
 */
AranyaError aranya_create_team_quic_sync_config_build_ext(struct AranyaCreateTeamQuicSyncConfigBuilder *cfg,
                                                          struct AranyaCreateTeamQuicSyncConfig *out,
                                                          struct AranyaExtError *__ext_err);

/**
 * Attempts to construct an [`AranyaAddTeamQuicSyncConfig`](@ref AranyaAddTeamQuicSyncConfig).
 *
 * This function consumes and releases any resources associated
 * with the memory pointed to by `cfg`.
 *
 * @param[in] cfg a pointer to the QUIC sync config builder
 * @param[out] out a pointer to write the QUIC sync config to
 *
 * @relates AranyaAddTeamQuicSyncConfigBuilder.
 */
AranyaError aranya_add_team_quic_sync_config_build(struct AranyaAddTeamQuicSyncConfigBuilder *cfg,
                                                   struct AranyaAddTeamQuicSyncConfig *out);

/**
 * Attempts to construct an [`AranyaAddTeamQuicSyncConfig`](@ref AranyaAddTeamQuicSyncConfig).
 *
 * This function consumes and releases any resources associated
 * with the memory pointed to by `cfg`.
 *
 * @param[in] cfg a pointer to the QUIC sync config builder
 * @param[out] out a pointer to write the QUIC sync config to
 *
 * @relates AranyaAddTeamQuicSyncConfigBuilder.
 */
AranyaError aranya_add_team_quic_sync_config_build_ext(struct AranyaAddTeamQuicSyncConfigBuilder *cfg,
                                                       struct AranyaAddTeamQuicSyncConfig *out,
                                                       struct AranyaExtError *__ext_err);

/**
 * Initializes `AranyaAddTeamConfigBuilder`.
 *
 * When no longer needed, `out`'s resources must be released
 * with its cleanup routine.
 *
 * @relates AranyaAddTeamConfigBuilder
 */
AranyaError aranya_add_team_config_builder_init(struct AranyaAddTeamConfigBuilder *out);

/**
 * Releases any resources associated with `ptr`.
 *
 * `ptr` must either be null or initialized by `::aranya_add_team_config_builder_init`.
 *
 * @relates AranyaAddTeamConfigBuilder
 */
AranyaError aranya_add_team_config_builder_cleanup(struct AranyaAddTeamConfigBuilder *ptr);

/**
 * Initializes `AranyaCreateTeamConfigBuilder`.
 *
 * When no longer needed, `out`'s resources must be released
 * with its cleanup routine.
 *
 * @relates AranyaCreateTeamConfigBuilder
 */
AranyaError aranya_create_team_config_builder_init(struct AranyaCreateTeamConfigBuilder *out);

/**
 * Releases any resources associated with `ptr`.
 *
 * `ptr` must either be null or initialized by `::aranya_create_team_config_builder_init`.
 *
 * @relates AranyaCreateTeamConfigBuilder
 */
AranyaError aranya_create_team_config_builder_cleanup(struct AranyaCreateTeamConfigBuilder *ptr);

/**
 * Configures QUIC syncer for [`AranyaAddTeamConfigBuilder`](@ref AranyaAddTeamConfigBuilder).
 *
 * By default, the QUIC syncer config is not set.
 *
 * @param[in,out] cfg a pointer to the builder for a team config
 * @param[in] quic set the QUIC syncer config
 *
 * @relates AranyaAddTeamConfigBuilder.
 */
AranyaError aranya_add_team_config_builder_set_quic_syncer(struct AranyaAddTeamConfigBuilder *cfg,
                                                           struct AranyaAddTeamQuicSyncConfig *quic);

/**
 * Configures QUIC syncer for [`AranyaAddTeamConfigBuilder`](@ref AranyaAddTeamConfigBuilder).
 *
 * By default, the QUIC syncer config is not set.
 *
 * @param[in,out] cfg a pointer to the builder for a team config
 * @param[in] quic set the QUIC syncer config
 *
 * @relates AranyaAddTeamConfigBuilder.
 */
AranyaError aranya_add_team_config_builder_set_quic_syncer_ext(struct AranyaAddTeamConfigBuilder *cfg,
                                                               struct AranyaAddTeamQuicSyncConfig *quic,
                                                               struct AranyaExtError *__ext_err);

/**
 * Configures team ID field for [`AranyaAddTeamConfigBuilder`](@ref AranyaAddTeamConfigBuilder).
 *
 * By default, the team ID is not set.
 *
 * @param[in,out] cfg a pointer to the builder for a team config
 * @param[in] id a pointer to a
 *
 * @relates AranyaAddTeamConfigBuilder.
 */
AranyaError aranya_add_team_config_builder_set_id(struct AranyaAddTeamConfigBuilder *cfg,
                                                  const struct AranyaTeamId *team_id);

/**
 * Configures team ID field for [`AranyaAddTeamConfigBuilder`](@ref AranyaAddTeamConfigBuilder).
 *
 * By default, the team ID is not set.
 *
 * @param[in,out] cfg a pointer to the builder for a team config
 * @param[in] id a pointer to a
 *
 * @relates AranyaAddTeamConfigBuilder.
 */
AranyaError aranya_add_team_config_builder_set_id_ext(struct AranyaAddTeamConfigBuilder *cfg,
                                                      const struct AranyaTeamId *team_id,
                                                      struct AranyaExtError *__ext_err);

/**
 * Attempts to construct an [`AranyaAddTeamConfig`](@ref AranyaAddTeamConfig).
 *
 * This function consumes and releases any resources associated
 * with the memory pointed to by `cfg`.
 *
 * @param[in] cfg a pointer to the team config builder
 * @param[out] out a pointer to write the team config to
 *
 * @relates AranyaAddTeamConfigBuilder.
 */
AranyaError aranya_add_team_config_build(struct AranyaAddTeamConfigBuilder *cfg,
                                         struct AranyaAddTeamConfig *out);

/**
 * Attempts to construct an [`AranyaAddTeamConfig`](@ref AranyaAddTeamConfig).
 *
 * This function consumes and releases any resources associated
 * with the memory pointed to by `cfg`.
 *
 * @param[in] cfg a pointer to the team config builder
 * @param[out] out a pointer to write the team config to
 *
 * @relates AranyaAddTeamConfigBuilder.
 */
AranyaError aranya_add_team_config_build_ext(struct AranyaAddTeamConfigBuilder *cfg,
                                             struct AranyaAddTeamConfig *out,
                                             struct AranyaExtError *__ext_err);

/**
 * Configures QUIC syncer for [`AranyaCreateTeamConfigBuilder`](@ref AranyaCreateTeamConfigBuilder).
 *
 * By default, the QUIC syncer config is not set.
 *
 * @param[in,out] cfg a pointer to the builder for a team config
 * @param[in] quic set the QUIC syncer config
 *
 * @relates AranyaCreateTeamConfigBuilder.
 */
AranyaError aranya_create_team_config_builder_set_quic_syncer(struct AranyaCreateTeamConfigBuilder *cfg,
                                                              struct AranyaCreateTeamQuicSyncConfig *quic);

/**
 * Configures QUIC syncer for [`AranyaCreateTeamConfigBuilder`](@ref AranyaCreateTeamConfigBuilder).
 *
 * By default, the QUIC syncer config is not set.
 *
 * @param[in,out] cfg a pointer to the builder for a team config
 * @param[in] quic set the QUIC syncer config
 *
 * @relates AranyaCreateTeamConfigBuilder.
 */
AranyaError aranya_create_team_config_builder_set_quic_syncer_ext(struct AranyaCreateTeamConfigBuilder *cfg,
                                                                  struct AranyaCreateTeamQuicSyncConfig *quic,
                                                                  struct AranyaExtError *__ext_err);

/**
 * Attempts to construct a [`AranyaCreateTeamConfig`](@ref AranyaCreateTeamConfig).
 *
 * This function consumes and releases any resources associated
 * with the memory pointed to by `cfg`.
 *
 * @param[in] cfg a pointer to the team config builder
 * @param[out] out a pointer to write the team config to
 *
 * @relates AranyaCreateTeamConfigBuilder.
 */
AranyaError aranya_create_team_config_build(struct AranyaCreateTeamConfigBuilder *cfg,
                                            struct AranyaCreateTeamConfig *out);

/**
 * Attempts to construct a [`AranyaCreateTeamConfig`](@ref AranyaCreateTeamConfig).
 *
 * This function consumes and releases any resources associated
 * with the memory pointed to by `cfg`.
 *
 * @param[in] cfg a pointer to the team config builder
 * @param[out] out a pointer to write the team config to
 *
 * @relates AranyaCreateTeamConfigBuilder.
 */
AranyaError aranya_create_team_config_build_ext(struct AranyaCreateTeamConfigBuilder *cfg,
                                                struct AranyaCreateTeamConfig *out,
                                                struct AranyaExtError *__ext_err);

/**
 * Initializes `AranyaSyncPeerConfigBuilder`.
 *
 * When no longer needed, `out`'s resources must be released
 * with its cleanup routine.
 *
 * @relates AranyaSyncPeerConfigBuilder
 */
AranyaError aranya_sync_peer_config_builder_init(struct AranyaSyncPeerConfigBuilder *out);

/**
 * Releases any resources associated with `ptr`.
 *
 * `ptr` must either be null or initialized by `::aranya_sync_peer_config_builder_init`.
 *
 * @relates AranyaSyncPeerConfigBuilder
 */
AranyaError aranya_sync_peer_config_builder_cleanup(struct AranyaSyncPeerConfigBuilder *ptr);

/**
 * Attempts to build a [`AranyaSyncPeerConfig`](@ref AranyaSyncPeerConfig).
 *
 * This function consumes and releases any resources associated
 * with the memory pointed to by `cfg`.
 *
 * @param[in] cfg a pointer to the builder for a sync config
 * @param[out] out a pointer to write the sync config to
 *
 * @relates AranyaSyncPeerConfigBuilder.
 */
AranyaError aranya_sync_peer_config_build(struct AranyaSyncPeerConfigBuilder *cfg,
                                          struct AranyaSyncPeerConfig *out);

/**
 * Attempts to build a [`AranyaSyncPeerConfig`](@ref AranyaSyncPeerConfig).
 *
 * This function consumes and releases any resources associated
 * with the memory pointed to by `cfg`.
 *
 * @param[in] cfg a pointer to the builder for a sync config
 * @param[out] out a pointer to write the sync config to
 *
 * @relates AranyaSyncPeerConfigBuilder.
 */
AranyaError aranya_sync_peer_config_build_ext(struct AranyaSyncPeerConfigBuilder *cfg,
                                              struct AranyaSyncPeerConfig *out,
                                              struct AranyaExtError *__ext_err);

/**
 * Configures how often the peer will be synced with.
 *
 * By default, the interval is not set. It is an error to call
 * [`aranya_sync_peer_config_build`](@ref aranya_sync_peer_config_build) before setting the interval with
 * this function
 *
 * @param[in,out] cfg a pointer to the builder for a sync config
 * @param[in] interval Set the interval at which syncing occurs (maximum 1 year)
 *
 * @relates AranyaSyncPeerConfigBuilder.
 */
AranyaError aranya_sync_peer_config_builder_set_interval(struct AranyaSyncPeerConfigBuilder *cfg,
                                                         AranyaDuration interval);

/**
 * Configures how often the peer will be synced with.
 *
 * By default, the interval is not set. It is an error to call
 * [`aranya_sync_peer_config_build`](@ref aranya_sync_peer_config_build) before setting the interval with
 * this function
 *
 * @param[in,out] cfg a pointer to the builder for a sync config
 * @param[in] interval Set the interval at which syncing occurs (maximum 1 year)
 *
 * @relates AranyaSyncPeerConfigBuilder.
 */
AranyaError aranya_sync_peer_config_builder_set_interval_ext(struct AranyaSyncPeerConfigBuilder *cfg,
                                                             AranyaDuration interval,
                                                             struct AranyaExtError *__ext_err);

/**
 * Updates the config so the peer will be scheduled for an immediate sync when added.
 *
 * Overrides [`aranya_sync_peer_config_builder_set_sync_later`](@ref aranya_sync_peer_config_builder_set_sync_later) if invoked afterward.
 *
 * By default, the peer is scheduled for an immediate sync.
 *
 * @param[in,out] cfg a pointer to the builder for a sync config
 *
 * @relates AranyaSyncPeerConfigBuilder.
 */
AranyaError aranya_sync_peer_config_builder_set_sync_now(struct AranyaSyncPeerConfigBuilder *cfg);

/**
 * Updates the config so the peer will be scheduled for an immediate sync when added.
 *
 * Overrides [`aranya_sync_peer_config_builder_set_sync_later`](@ref aranya_sync_peer_config_builder_set_sync_later) if invoked afterward.
 *
 * By default, the peer is scheduled for an immediate sync.
 *
 * @param[in,out] cfg a pointer to the builder for a sync config
 *
 * @relates AranyaSyncPeerConfigBuilder.
 */
AranyaError aranya_sync_peer_config_builder_set_sync_now_ext(struct AranyaSyncPeerConfigBuilder *cfg,
                                                             struct AranyaExtError *__ext_err);

/**
 * Updates the config so the peer will be scheduled for an immediate sync when added.
 *
 * Overrides [`aranya_sync_peer_config_builder_set_sync_now`](@ref aranya_sync_peer_config_builder_set_sync_now) if invoked afterward.
 *
 * By default, the peer is scheduled for an immediate sync.
 *
 * @param[in,out] cfg a pointer to the builder for a sync config
 *
 * @relates AranyaSyncPeerConfigBuilder.
 */
AranyaError aranya_sync_peer_config_builder_set_sync_later(struct AranyaSyncPeerConfigBuilder *cfg);

/**
 * Updates the config so the peer will be scheduled for an immediate sync when added.
 *
 * Overrides [`aranya_sync_peer_config_builder_set_sync_now`](@ref aranya_sync_peer_config_builder_set_sync_now) if invoked afterward.
 *
 * By default, the peer is scheduled for an immediate sync.
 *
 * @param[in,out] cfg a pointer to the builder for a sync config
 *
 * @relates AranyaSyncPeerConfigBuilder.
 */
AranyaError aranya_sync_peer_config_builder_set_sync_later_ext(struct AranyaSyncPeerConfigBuilder *cfg,
                                                               struct AranyaExtError *__ext_err);

#if defined(ENABLE_ARANYA_PREVIEW)
/**
 * Sets whether automatic syncing should occur when a hello message is received from this peer
 * indicating they have a head that we don't have.
 *
 * By default, sync on hello is disabled.
 * @param[in,out] cfg a pointer to the builder for a sync config
 * @param[in] sync_on_hello whether to enable or disable sync on hello (0 = false, non-zero = true)
 *
 * @relates AranyaSyncPeerConfigBuilder.
 */
AranyaError aranya_sync_peer_config_builder_set_sync_on_hello(struct AranyaSyncPeerConfigBuilder *cfg,
                                                              uint32_t sync_on_hello);
#endif

#if defined(ENABLE_ARANYA_PREVIEW)
/**
 * Sets whether automatic syncing should occur when a hello message is received from this peer
 * indicating they have a head that we don't have.
 *
 * By default, sync on hello is disabled.
 * @param[in,out] cfg a pointer to the builder for a sync config
 * @param[in] sync_on_hello whether to enable or disable sync on hello (0 = false, non-zero = true)
 *
 * @relates AranyaSyncPeerConfigBuilder.
 */
AranyaError aranya_sync_peer_config_builder_set_sync_on_hello_ext(struct AranyaSyncPeerConfigBuilder *cfg,
                                                                  uint32_t sync_on_hello,
                                                                  struct AranyaExtError *__ext_err);
#endif

/**
 * Assign a role to a device.
 * Setup default roles on team.
 *
 * This sets up the following roles with default permissions as
 * defined in Aranya's default policy:
 * - admin
 * - operator
 * - member
 *
 * Returns an `AranyaBufferTooSmall` error if the output buffer is too small to hold the roles.
 * Writes the number of roles that would have been returned to `roles_len`.
 *
 * N.B. this function is meant to be called once to set up the default roles.
 * Subsequent calls will result in an error if the default roles were already created.
 *
 * @param[in] client the Aranya Client
 * @param[in] team the team's ID
 * @param[in] owning_role the ID of the owning role
 * @param[in] roles_out returns a list of roles that own `role`
 * @param[in,out] roles_len the number of roles written to the buffer.
 *
 * @relates AranyaClient.
 */
AranyaError aranya_setup_default_roles(struct AranyaClient *client,
                                       const struct AranyaTeamId *team,
                                       const struct AranyaRoleId *owning_role,
                                       struct AranyaRole *roles_out,
                                       size_t *roles_len);

/**
 * Assign a role to a device.
 * Setup default roles on team.
 *
 * This sets up the following roles with default permissions as
 * defined in Aranya's default policy:
 * - admin
 * - operator
 * - member
 *
 * Returns an `AranyaBufferTooSmall` error if the output buffer is too small to hold the roles.
 * Writes the number of roles that would have been returned to `roles_len`.
 *
 * N.B. this function is meant to be called once to set up the default roles.
 * Subsequent calls will result in an error if the default roles were already created.
 *
 * @param[in] client the Aranya Client
 * @param[in] team the team's ID
 * @param[in] owning_role the ID of the owning role
 * @param[in] roles_out returns a list of roles that own `role`
 * @param[in,out] roles_len the number of roles written to the buffer.
 *
 * @relates AranyaClient.
 */
AranyaError aranya_setup_default_roles_ext(struct AranyaClient *client,
                                           const struct AranyaTeamId *team,
                                           const struct AranyaRoleId *owning_role,
                                           struct AranyaRole *roles_out,
                                           size_t *roles_len,
                                           struct AranyaExtError *__ext_err);

#if defined(ENABLE_ARANYA_PREVIEW)
/**
 * Adds `owning_role` as an owner of role.
 *
 * @param[in] client the Aranya Client
 * @param[in] team the team's ID
 * @param[in] role ID of the subject role
 * @param[in] owning_role ID of the owning role
 *
 * @relates AranyaClient.
 */
AranyaError aranya_add_role_owner(const struct AranyaClient *client,
                                  const struct AranyaTeamId *team,
                                  const struct AranyaRoleId *role,
                                  const struct AranyaRoleId *owning_role);
#endif

#if defined(ENABLE_ARANYA_PREVIEW)
/**
 * Adds `owning_role` as an owner of role.
 *
 * @param[in] client the Aranya Client
 * @param[in] team the team's ID
 * @param[in] role ID of the subject role
 * @param[in] owning_role ID of the owning role
 *
 * @relates AranyaClient.
 */
AranyaError aranya_add_role_owner_ext(const struct AranyaClient *client,
                                      const struct AranyaTeamId *team,
                                      const struct AranyaRoleId *role,
                                      const struct AranyaRoleId *owning_role,
                                      struct AranyaExtError *__ext_err);
#endif

#if defined(ENABLE_ARANYA_PREVIEW)
/**
 * Removes an owning_role as an owner of role.
 *
 * @param[in] client the Aranya Client
 * @param[in] team the team's ID
 * @param[in] role the ID of the subject role
 * @param[in] owning_role ID of the owning role
 *
 * @relates AranyaClient.
 */
AranyaError aranya_remove_role_owner(const struct AranyaClient *client,
                                     const struct AranyaTeamId *team,
                                     const struct AranyaRoleId *role,
                                     const struct AranyaRoleId *owning_role);
#endif

#if defined(ENABLE_ARANYA_PREVIEW)
/**
 * Removes an owning_role as an owner of role.
 *
 * @param[in] client the Aranya Client
 * @param[in] team the team's ID
 * @param[in] role the ID of the subject role
 * @param[in] owning_role ID of the owning role
 *
 * @relates AranyaClient.
 */
AranyaError aranya_remove_role_owner_ext(const struct AranyaClient *client,
                                         const struct AranyaTeamId *team,
                                         const struct AranyaRoleId *role,
                                         const struct AranyaRoleId *owning_role,
                                         struct AranyaExtError *__ext_err);
#endif

/**
 * Returns the roles that own `role`.
 *
 * Returns an `AranyaBufferTooSmall` error if the output buffer is too small to hold the roles.
 * Writes the number of roles that would have been returned to `roles_len`.
 * The application can use `roles_len` to allocate a larger buffer.
 *
 * @param[in] client the Aranya Client
 * @param[in] team the team's ID
 * @param[in] role the ID of the subject role
 * @param[in] roles_out returns a list of roles that own `role`
 * @param[in,out] roles_len the number of roles written to the buffer.
 *
 * @relates AranyaClient.
 */
AranyaError aranya_role_owners(const struct AranyaClient *client,
                               const struct AranyaTeamId *team,
                               const struct AranyaRoleId *role,
                               struct AranyaRole *roles_out,
                               size_t *roles_len);

/**
 * Returns the roles that own `role`.
 *
 * Returns an `AranyaBufferTooSmall` error if the output buffer is too small to hold the roles.
 * Writes the number of roles that would have been returned to `roles_len`.
 * The application can use `roles_len` to allocate a larger buffer.
 *
 * @param[in] client the Aranya Client
 * @param[in] team the team's ID
 * @param[in] role the ID of the subject role
 * @param[in] roles_out returns a list of roles that own `role`
 * @param[in,out] roles_len the number of roles written to the buffer.
 *
 * @relates AranyaClient.
 */
AranyaError aranya_role_owners_ext(const struct AranyaClient *client,
                                   const struct AranyaTeamId *team,
                                   const struct AranyaRoleId *role,
                                   struct AranyaRole *roles_out,
                                   size_t *roles_len,
                                   struct AranyaExtError *__ext_err);

#if defined(ENABLE_ARANYA_PREVIEW)
/**
 * Assigns a role management permission to a managing role.
 *
 * @param[in] client the Aranya Client
 * @param[in] team the team's ID
 * @param[in] role the ID of the subject role
 * @param[in] managing_role the ID of the managing role
 * @param[in] perm the management permission to assign
 *
 * @relates AranyaClient.
 */
AranyaError aranya_assign_role_management_permission(const struct AranyaClient *client,
                                                     const struct AranyaTeamId *team,
                                                     const struct AranyaRoleId *role,
                                                     const struct AranyaRoleId *managing_role,
                                                     AranyaRoleManagementPermission perm);
#endif

#if defined(ENABLE_ARANYA_PREVIEW)
/**
 * Assigns a role management permission to a managing role.
 *
 * @param[in] client the Aranya Client
 * @param[in] team the team's ID
 * @param[in] role the ID of the subject role
 * @param[in] managing_role the ID of the managing role
 * @param[in] perm the management permission to assign
 *
 * @relates AranyaClient.
 */
AranyaError aranya_assign_role_management_permission_ext(const struct AranyaClient *client,
                                                         const struct AranyaTeamId *team,
                                                         const struct AranyaRoleId *role,
                                                         const struct AranyaRoleId *managing_role,
                                                         AranyaRoleManagementPermission perm,
                                                         struct AranyaExtError *__ext_err);
#endif

#if defined(ENABLE_ARANYA_PREVIEW)
/**
 * Revokes a role management permission from a managing role.
 *
 * @param[in] client the Aranya Client
 * @param[in] team the team's ID
 * @param[in] role the ID of the subject role
 * @param[in] managing_role the ID of the managing role
 * @param[in] perm the management permission to assign
 *
 * @relates AranyaClient.
 */
AranyaError aranya_revoke_role_management_permission(const struct AranyaClient *client,
                                                     const struct AranyaTeamId *team,
                                                     const struct AranyaRoleId *role,
                                                     const struct AranyaRoleId *managing_role,
                                                     AranyaRoleManagementPermission perm);
#endif

#if defined(ENABLE_ARANYA_PREVIEW)
/**
 * Revokes a role management permission from a managing role.
 *
 * @param[in] client the Aranya Client
 * @param[in] team the team's ID
 * @param[in] role the ID of the subject role
 * @param[in] managing_role the ID of the managing role
 * @param[in] perm the management permission to assign
 *
 * @relates AranyaClient.
 */
AranyaError aranya_revoke_role_management_permission_ext(const struct AranyaClient *client,
                                                         const struct AranyaTeamId *team,
                                                         const struct AranyaRoleId *role,
                                                         const struct AranyaRoleId *managing_role,
                                                         AranyaRoleManagementPermission perm,
                                                         struct AranyaExtError *__ext_err);
#endif

/**
 * Changes the `role` on a `device`
 *
 * This will change the device's current role to the new role assigned.
 *
 * Permission to perform this operation is checked against the Aranya policy.
 *
 * @param[in] client the Aranya Client
 * @param[in] team the team's ID
 * @param[in] device the device's ID
 * @param[in] old_role the ID of the role currently assigned to the device
 * @param[in] new_role the ID of the role to assign to the device
 *
 * @relates AranyaClient.
 */
AranyaError aranya_change_role(const struct AranyaClient *client,
                               const struct AranyaTeamId *team,
                               const struct AranyaDeviceId *device,
                               const struct AranyaRoleId *old_role,
                               const struct AranyaRoleId *new_role);

/**
 * Changes the `role` on a `device`
 *
 * This will change the device's current role to the new role assigned.
 *
 * Permission to perform this operation is checked against the Aranya policy.
 *
 * @param[in] client the Aranya Client
 * @param[in] team the team's ID
 * @param[in] device the device's ID
 * @param[in] old_role the ID of the role currently assigned to the device
 * @param[in] new_role the ID of the role to assign to the device
 *
 * @relates AranyaClient.
 */
AranyaError aranya_change_role_ext(const struct AranyaClient *client,
                                   const struct AranyaTeamId *team,
                                   const struct AranyaDeviceId *device,
                                   const struct AranyaRoleId *old_role,
                                   const struct AranyaRoleId *new_role,
                                   struct AranyaExtError *__ext_err);

/**
 * Returns all of the roles for this team.
 *
 * Returns an `AranyaBufferTooSmall` error if the output buffer is too small to hold the roles.
 * Writes the number of roles that would have been returned to `roles_len`.
 * The application can use `roles_len` to allocate a larger buffer.
 *
 * @param[in] client the Aranya Client
 * @param[in] team the team's ID
 * @param[out] roles_out returns a list of roles on the team
 * @param[in,out] roles_len the number of roles written to the buffer.
 *
 * @relates AranyaClient.
 */
AranyaError aranya_team_roles(const struct AranyaClient *client,
                              const struct AranyaTeamId *team,
                              struct AranyaRole *roles_out,
                              size_t *roles_out_len);

/**
 * Returns all of the roles for this team.
 *
 * Returns an `AranyaBufferTooSmall` error if the output buffer is too small to hold the roles.
 * Writes the number of roles that would have been returned to `roles_len`.
 * The application can use `roles_len` to allocate a larger buffer.
 *
 * @param[in] client the Aranya Client
 * @param[in] team the team's ID
 * @param[out] roles_out returns a list of roles on the team
 * @param[in,out] roles_len the number of roles written to the buffer.
 *
 * @relates AranyaClient.
 */
AranyaError aranya_team_roles_ext(const struct AranyaClient *client,
                                  const struct AranyaTeamId *team,
                                  struct AranyaRole *roles_out,
                                  size_t *roles_out_len,
                                  struct AranyaExtError *__ext_err);

#if defined(ENABLE_ARANYA_PREVIEW)
/**
 * Create a role.
 *
 * The `owning_role` is the initial owner of the new role.
 *
 * Permission to perform this operation is checked against the Aranya policy.
 *
 * @param[in] client the Aranya Client
 * @param[in] team the team's ID
 * @param[in] role_name the name of the new role
 * @param[in] owning_role the role ID of the role that will own the new role
 * @param[out] role_out the newly created role
 *
 * @relates AranyaClient
 */
AranyaError aranya_create_role(const struct AranyaClient *client,
                               const struct AranyaTeamId *team,
                               AranyaRoleName role_name,
                               const struct AranyaRoleId *owning_role,
                               struct AranyaRole *role_out);
#endif

#if defined(ENABLE_ARANYA_PREVIEW)
/**
 * Create a role.
 *
 * The `owning_role` is the initial owner of the new role.
 *
 * Permission to perform this operation is checked against the Aranya policy.
 *
 * @param[in] client the Aranya Client
 * @param[in] team the team's ID
 * @param[in] role_name the name of the new role
 * @param[in] owning_role the role ID of the role that will own the new role
 * @param[out] role_out the newly created role
 *
 * @relates AranyaClient
 */
AranyaError aranya_create_role_ext(const struct AranyaClient *client,
                                   const struct AranyaTeamId *team,
                                   AranyaRoleName role_name,
                                   const struct AranyaRoleId *owning_role,
                                   struct AranyaRole *role_out,
                                   struct AranyaExtError *__ext_err);
#endif

#if defined(ENABLE_ARANYA_PREVIEW)
/**
 * Delete a role.
 *
 * The role must not be assigned to any devices, nor should it own any
 * other roles.
 *
 * Permission to perform this operation is checked against the Aranya policy.
 *
 * @param[in] client the Aranya Client
 * @param[in] team the team's ID
 * @param[in] role the ID of the role to delete
 *
 * @relates AranyaClient
 */
AranyaError aranya_delete_role(const struct AranyaClient *client,
                               const struct AranyaTeamId *team,
                               const struct AranyaRoleId *role);
#endif

#if defined(ENABLE_ARANYA_PREVIEW)
/**
 * Delete a role.
 *
 * The role must not be assigned to any devices, nor should it own any
 * other roles.
 *
 * Permission to perform this operation is checked against the Aranya policy.
 *
 * @param[in] client the Aranya Client
 * @param[in] team the team's ID
 * @param[in] role the ID of the role to delete
 *
 * @relates AranyaClient
 */
AranyaError aranya_delete_role_ext(const struct AranyaClient *client,
                                   const struct AranyaTeamId *team,
                                   const struct AranyaRoleId *role,
                                   struct AranyaExtError *__ext_err);
#endif

#if defined(ENABLE_ARANYA_PREVIEW)
/**
 * Add a permission to a role.
 *
 * It is an error to add a permission already added to the role.
 *
 * Permission to perform this operation is checked against the Aranya policy.
 *
 * @param[in] client the Aranya Client
 * @param[in] team the team's ID
 * @param[in] role the role ID of the role the permission is being added to
 * @param[in] perm a permission to add to the role
 */
AranyaError aranya_add_perm_to_role(const struct AranyaClient *client,
                                    const struct AranyaTeamId *team,
                                    const struct AranyaRoleId *role,
                                    AranyaPermission perm);
#endif

#if defined(ENABLE_ARANYA_PREVIEW)
/**
 * Add a permission to a role.
 *
 * It is an error to add a permission already added to the role.
 *
 * Permission to perform this operation is checked against the Aranya policy.
 *
 * @param[in] client the Aranya Client
 * @param[in] team the team's ID
 * @param[in] role the role ID of the role the permission is being added to
 * @param[in] perm a permission to add to the role
 */
AranyaError aranya_add_perm_to_role_ext(const struct AranyaClient *client,
                                        const struct AranyaTeamId *team,
                                        const struct AranyaRoleId *role,
                                        AranyaPermission perm,
                                        struct AranyaExtError *__ext_err);
#endif

#if defined(ENABLE_ARANYA_PREVIEW)
/**
 * Remove a permission from a role.
 *
 * It is an error to remove a permission not added to the role.
 *
 * Permission to perform this operation is checked against the Aranya policy.
 *
 * @param[in] client the Aranya Client
 * @param[in] team the team's ID
 * @param[in] role the role ID of the role the permission is being removed from
 * @param[in] perm a permission to remove from the role
 */
AranyaError aranya_remove_perm_from_role(const struct AranyaClient *client,
                                         const struct AranyaTeamId *team,
                                         const struct AranyaRoleId *role,
                                         AranyaPermission perm);
#endif

#if defined(ENABLE_ARANYA_PREVIEW)
/**
 * Remove a permission from a role.
 *
 * It is an error to remove a permission not added to the role.
 *
 * Permission to perform this operation is checked against the Aranya policy.
 *
 * @param[in] client the Aranya Client
 * @param[in] team the team's ID
 * @param[in] role the role ID of the role the permission is being removed from
 * @param[in] perm a permission to remove from the role
 */
AranyaError aranya_remove_perm_from_role_ext(const struct AranyaClient *client,
                                             const struct AranyaTeamId *team,
                                             const struct AranyaRoleId *role,
                                             AranyaPermission perm,
                                             struct AranyaExtError *__ext_err);
#endif

/**
 * Assign a role to a device.
 *
 * This will change the device's currently assigned role to the new role.
 *
 * Permission to perform this operation is checked against the Aranya policy.
 *
 * It is an error if the device has already been assigned a role.
 * If you want to assign a different role to a device that already
 * has a role, use `change_role()` instead.
 *
 * @param[in] client the Aranya Client
 * @param[in] team the team's ID
 * @param[in] device the device's ID
 * @param[in] role_id the ID of the role to assign to the device
 *
 * @relates AranyaClient.
 */
AranyaError aranya_assign_role(const struct AranyaClient *client,
                               const struct AranyaTeamId *team,
                               const struct AranyaDeviceId *device,
                               const struct AranyaRoleId *role_id);

/**
 * Assign a role to a device.
 *
 * This will change the device's currently assigned role to the new role.
 *
 * Permission to perform this operation is checked against the Aranya policy.
 *
 * It is an error if the device has already been assigned a role.
 * If you want to assign a different role to a device that already
 * has a role, use `change_role()` instead.
 *
 * @param[in] client the Aranya Client
 * @param[in] team the team's ID
 * @param[in] device the device's ID
 * @param[in] role_id the ID of the role to assign to the device
 *
 * @relates AranyaClient.
 */
AranyaError aranya_assign_role_ext(const struct AranyaClient *client,
                                   const struct AranyaTeamId *team,
                                   const struct AranyaDeviceId *device,
                                   const struct AranyaRoleId *role_id,
                                   struct AranyaExtError *__ext_err);

/**
 * Revoke a role from a device.
 *
 * Permission to perform this operation is checked against the Aranya policy.
 *
 * @param[in] client the Aranya Client
 * @param[in] team the team's ID
 * @param[in] device the device's ID
 * @param[in] role_id the ID of the role to revoke from the device.
 *
 * @relates AranyaClient.
 */
AranyaError aranya_revoke_role(const struct AranyaClient *client,
                               const struct AranyaTeamId *team,
                               const struct AranyaDeviceId *device,
                               const struct AranyaRoleId *role_id);

/**
 * Revoke a role from a device.
 *
 * Permission to perform this operation is checked against the Aranya policy.
 *
 * @param[in] client the Aranya Client
 * @param[in] team the team's ID
 * @param[in] device the device's ID
 * @param[in] role_id the ID of the role to revoke from the device.
 *
 * @relates AranyaClient.
 */
AranyaError aranya_revoke_role_ext(const struct AranyaClient *client,
                                   const struct AranyaTeamId *team,
                                   const struct AranyaDeviceId *device,
                                   const struct AranyaRoleId *role_id,
                                   struct AranyaExtError *__ext_err);

/**
 * Create a channel label.
 *
 * Permission to perform this operation is checked against the Aranya policy.
 *
 * @param[in] client the Aranya Client
 * @param[in] team the team's ID
 * @param[in] name label name string
 * @param[in] managing_role_id the ID of the role that manages this label
 *
 * @relates AranyaClient.
 */
AranyaError aranya_create_label(const struct AranyaClient *client,
                                const struct AranyaTeamId *team,
                                AranyaLabelName name,
                                const struct AranyaRoleId *managing_role_id,
                                struct AranyaLabelId *__output);

/**
 * Create a channel label.
 *
 * Permission to perform this operation is checked against the Aranya policy.
 *
 * @param[in] client the Aranya Client
 * @param[in] team the team's ID
 * @param[in] name label name string
 * @param[in] managing_role_id the ID of the role that manages this label
 *
 * @relates AranyaClient.
 */
AranyaError aranya_create_label_ext(const struct AranyaClient *client,
                                    const struct AranyaTeamId *team,
                                    AranyaLabelName name,
                                    const struct AranyaRoleId *managing_role_id,
                                    struct AranyaLabelId *__output,
                                    struct AranyaExtError *__ext_err);

/**
 * Delete a channel label.
 *
 * Permission to perform this operation is checked against the Aranya policy.
 *
 * @param[in] client the Aranya Client
 * @param[in] team the team's ID
 * @param[in] label_id the channel label ID  to delete.
 *
 * @relates AranyaClient.
 */
AranyaError aranya_delete_label(const struct AranyaClient *client,
                                const struct AranyaTeamId *team,
                                const struct AranyaLabelId *label_id);

/**
 * Delete a channel label.
 *
 * Permission to perform this operation is checked against the Aranya policy.
 *
 * @param[in] client the Aranya Client
 * @param[in] team the team's ID
 * @param[in] label_id the channel label ID  to delete.
 *
 * @relates AranyaClient.
 */
AranyaError aranya_delete_label_ext(const struct AranyaClient *client,
                                    const struct AranyaTeamId *team,
                                    const struct AranyaLabelId *label_id,
                                    struct AranyaExtError *__ext_err);

/**
 * Assign a label to a device so that it can be used for a channel.
 *
 * Permission to perform this operation is checked against the Aranya policy.
 *
 * @param[in] client the Aranya Client
 * @param[in] team the team's ID
 * @param[in] device the device ID  of the device to assign the label to.
 * @param[in] label_id the channel label ID
 *
 * @relates AranyaClient.
 */
AranyaError aranya_assign_label(const struct AranyaClient *client,
                                const struct AranyaTeamId *team,
                                const struct AranyaDeviceId *device,
                                const struct AranyaLabelId *label_id,
                                AranyaChanOp op);

/**
 * Assign a label to a device so that it can be used for a channel.
 *
 * Permission to perform this operation is checked against the Aranya policy.
 *
 * @param[in] client the Aranya Client
 * @param[in] team the team's ID
 * @param[in] device the device ID  of the device to assign the label to.
 * @param[in] label_id the channel label ID
 *
 * @relates AranyaClient.
 */
AranyaError aranya_assign_label_ext(const struct AranyaClient *client,
                                    const struct AranyaTeamId *team,
                                    const struct AranyaDeviceId *device,
                                    const struct AranyaLabelId *label_id,
                                    AranyaChanOp op,
                                    struct AranyaExtError *__ext_err);

/**
 * Revoke a label from a device.
 *
 * Permission to perform this operation is checked against the Aranya policy.
 *
 * @param[in] client the Aranya Client
 * @param[in] team the team's ID
 * @param[in] device the device ID  of the device to revoke the label from.
 * @param[in] label_id the channel label ID
 *
 * @relates AranyaClient.
 */
AranyaError aranya_revoke_label(const struct AranyaClient *client,
                                const struct AranyaTeamId *team,
                                const struct AranyaDeviceId *device,
                                const struct AranyaLabelId *label_id);

/**
 * Revoke a label from a device.
 *
 * Permission to perform this operation is checked against the Aranya policy.
 *
 * @param[in] client the Aranya Client
 * @param[in] team the team's ID
 * @param[in] device the device ID  of the device to revoke the label from.
 * @param[in] label_id the channel label ID
 *
 * @relates AranyaClient.
 */
AranyaError aranya_revoke_label_ext(const struct AranyaClient *client,
                                    const struct AranyaTeamId *team,
                                    const struct AranyaDeviceId *device,
                                    const struct AranyaLabelId *label_id,
                                    struct AranyaExtError *__ext_err);

#if defined(ENABLE_ARANYA_PREVIEW)
/**
 * Add label managing role.
 *
 * Permission to perform this operation is checked against the Aranya policy.
 *
 * @param[in] client the Aranya Client
 * @param[in] team the team's ID
 * @param[in] label_id the label ID
 * @param[in] managing_role_id the ID of the managing role
 *
 * @relates AranyaClient.
 */
AranyaError aranya_add_label_managing_role(const struct AranyaClient *client,
                                           const struct AranyaTeamId *team,
                                           const struct AranyaLabelId *label_id,
                                           const struct AranyaRoleId *managing_role_id);
#endif

#if defined(ENABLE_ARANYA_PREVIEW)
/**
 * Add label managing role.
 *
 * Permission to perform this operation is checked against the Aranya policy.
 *
 * @param[in] client the Aranya Client
 * @param[in] team the team's ID
 * @param[in] label_id the label ID
 * @param[in] managing_role_id the ID of the managing role
 *
 * @relates AranyaClient.
 */
AranyaError aranya_add_label_managing_role_ext(const struct AranyaClient *client,
                                               const struct AranyaTeamId *team,
                                               const struct AranyaLabelId *label_id,
                                               const struct AranyaRoleId *managing_role_id,
                                               struct AranyaExtError *__ext_err);
#endif

/**
 * Create a new graph/team with the current device as the owner.
 *
 * @param[in] client the Aranya Client
 * @param[in] cfg the Team Configuration
 * @param[out] __output the team's ID
 *
 * @relates AranyaClient.
 */
AranyaError aranya_create_team(const struct AranyaClient *client,
                               const struct AranyaCreateTeamConfig *cfg,
                               struct AranyaTeamId *__output);

/**
 * Create a new graph/team with the current device as the owner.
 *
 * @param[in] client the Aranya Client
 * @param[in] cfg the Team Configuration
 * @param[out] __output the team's ID
 *
 * @relates AranyaClient.
 */
AranyaError aranya_create_team_ext(const struct AranyaClient *client,
                                   const struct AranyaCreateTeamConfig *cfg,
                                   struct AranyaTeamId *__output,
                                   struct AranyaExtError *__ext_err);

/**
 * Return random bytes from Aranya's CSPRNG.
 *
 * This method can be used to generate a PSK seed IKM for the QUIC syncer.
 *
 * @param[in] client the Aranya Client
 * @param[out] buf buffer where random bytes are written to.
 * @param[in] buf_len the size of the buffer.
 *
 * @relates AranyaClient.
 */
AranyaError aranya_rand(const struct AranyaClient *client,
                        uint8_t *buf,
                        size_t buf_len);

/**
 * Return random bytes from Aranya's CSPRNG.
 *
 * This method can be used to generate a PSK seed IKM for the QUIC syncer.
 *
 * @param[in] client the Aranya Client
 * @param[out] buf buffer where random bytes are written to.
 * @param[in] buf_len the size of the buffer.
 *
 * @relates AranyaClient.
 */
AranyaError aranya_rand_ext(const struct AranyaClient *client,
                            uint8_t *buf,
                            size_t buf_len,
                            struct AranyaExtError *__ext_err);

/**
 * Return serialized PSK seed encrypted for another device on the team.
 *
 * The PSK seed will be encrypted using the public encryption key of the specified device on the team.
 *
 * Returns an `AranyaBufferTooSmall` error if the output buffer is too small to hold the seed bytes.
 * Writes the number of bytes that would have been returned to `seed_len`.
 * The application can use `seed_len` to allocate a larger buffer.
 *
 * @param[in] client the Aranya Client
 * @param[in] team_id the team's ID
 * @param[in] keybundle serialized keybundle byte buffer `KeyBundle`.
 * @param[in] keybundle_len the length of the keybundle
 * @param[out] seed the serialized, encrypted PSK seed.
 * @param[in,out] seed_len the number of bytes written to the seed buffer.
 *
 * This method will be removed soon since certificates will be used instead of PSKs in the future.
 *
 * @relates AranyaClient.
 */
AranyaError aranya_encrypt_psk_seed_for_peer(const struct AranyaClient *client,
                                             const struct AranyaTeamId *team_id,
                                             const uint8_t *keybundle,
                                             size_t keybundle_len,
                                             uint8_t *seed,
                                             size_t *seed_len);

/**
 * Return serialized PSK seed encrypted for another device on the team.
 *
 * The PSK seed will be encrypted using the public encryption key of the specified device on the team.
 *
 * Returns an `AranyaBufferTooSmall` error if the output buffer is too small to hold the seed bytes.
 * Writes the number of bytes that would have been returned to `seed_len`.
 * The application can use `seed_len` to allocate a larger buffer.
 *
 * @param[in] client the Aranya Client
 * @param[in] team_id the team's ID
 * @param[in] keybundle serialized keybundle byte buffer `KeyBundle`.
 * @param[in] keybundle_len the length of the keybundle
 * @param[out] seed the serialized, encrypted PSK seed.
 * @param[in,out] seed_len the number of bytes written to the seed buffer.
 *
 * This method will be removed soon since certificates will be used instead of PSKs in the future.
 *
 * @relates AranyaClient.
 */
AranyaError aranya_encrypt_psk_seed_for_peer_ext(const struct AranyaClient *client,
                                                 const struct AranyaTeamId *team_id,
                                                 const uint8_t *keybundle,
                                                 size_t keybundle_len,
                                                 uint8_t *seed,
                                                 size_t *seed_len,
                                                 struct AranyaExtError *__ext_err);

/**
 * Add a team to the local device store.
 *
 * @param[in] client the Aranya Client
 * @param[in] cfg the Team Configuration
 *
 * @relates AranyaClient.
 */
AranyaError aranya_add_team(const struct AranyaClient *client,
                            const struct AranyaAddTeamConfig *cfg);

/**
 * Add a team to the local device store.
 *
 * @param[in] client the Aranya Client
 * @param[in] cfg the Team Configuration
 *
 * @relates AranyaClient.
 */
AranyaError aranya_add_team_ext(const struct AranyaClient *client,
                                const struct AranyaAddTeamConfig *cfg,
                                struct AranyaExtError *__ext_err);

/**
 * Remove a team from local device storage.
 *
 * @param[in] client the Aranya Client
 * @param[in] team the team's ID
 *
 * @relates AranyaClient.
 */
AranyaError aranya_remove_team(const struct AranyaClient *client,
                               const struct AranyaTeamId *team);

/**
 * Remove a team from local device storage.
 *
 * @param[in] client the Aranya Client
 * @param[in] team the team's ID
 *
 * @relates AranyaClient.
 */
AranyaError aranya_remove_team_ext(const struct AranyaClient *client,
                                   const struct AranyaTeamId *team,
                                   struct AranyaExtError *__ext_err);

/**
 * Close the team and stop all operations on the graph.
 *
 * @param[in] client the Aranya Client
 * @param[in] team the team's ID
 *
 * @relates AranyaClient.
 */
AranyaError aranya_close_team(const struct AranyaClient *client,
                              const struct AranyaTeamId *team);

/**
 * Close the team and stop all operations on the graph.
 *
 * @param[in] client the Aranya Client
 * @param[in] team the team's ID
 *
 * @relates AranyaClient.
 */
AranyaError aranya_close_team_ext(const struct AranyaClient *client,
                                  const struct AranyaTeamId *team,
                                  struct AranyaExtError *__ext_err);

/**
 * Add a device to the team with the default role.
 *
 * Permission to perform this operation is checked against the Aranya policy.
 *
 * @param[in] client the Aranya Client
 * @param[in] team the team's ID
 * @param[in] keybundle serialized keybundle byte buffer `KeyBundle`.
 * @param[in] keybundle_len is the length of the serialized keybundle.
 * @param[in] role_id (optional) the ID of the role to assign to the device.
 *
 * @relates AranyaClient.
 */
AranyaError aranya_add_device_to_team(const struct AranyaClient *client,
                                      const struct AranyaTeamId *team,
                                      const uint8_t *keybundle,
                                      size_t keybundle_len,
                                      const struct AranyaRoleId *role_id);

/**
 * Add a device to the team with the default role.
 *
 * Permission to perform this operation is checked against the Aranya policy.
 *
 * @param[in] client the Aranya Client
 * @param[in] team the team's ID
 * @param[in] keybundle serialized keybundle byte buffer `KeyBundle`.
 * @param[in] keybundle_len is the length of the serialized keybundle.
 * @param[in] role_id (optional) the ID of the role to assign to the device.
 *
 * @relates AranyaClient.
 */
AranyaError aranya_add_device_to_team_ext(const struct AranyaClient *client,
                                          const struct AranyaTeamId *team,
                                          const uint8_t *keybundle,
                                          size_t keybundle_len,
                                          const struct AranyaRoleId *role_id,
                                          struct AranyaExtError *__ext_err);

/**
 * Remove a device from the team.
 *
 * Permission to perform this operation is checked against the Aranya policy.
 *
 * @param[in] client the Aranya Client
 * @param[in] team the team's ID
 * @param[in] device the device's ID
 *
 * @relates AranyaClient.
 */
AranyaError aranya_remove_device_from_team(const struct AranyaClient *client,
                                           const struct AranyaTeamId *team,
                                           const struct AranyaDeviceId *device);

/**
 * Remove a device from the team.
 *
 * Permission to perform this operation is checked against the Aranya policy.
 *
 * @param[in] client the Aranya Client
 * @param[in] team the team's ID
 * @param[in] device the device's ID
 *
 * @relates AranyaClient.
 */
AranyaError aranya_remove_device_from_team_ext(const struct AranyaClient *client,
                                               const struct AranyaTeamId *team,
                                               const struct AranyaDeviceId *device,
                                               struct AranyaExtError *__ext_err);

/**
 * Add the peer for automatic periodic Aranya state syncing.
 *
 * If a peer is not reachable on the network, sync errors
 * will appear in the tracing logs and
 * Aranya will be unable to sync state with that peer.
 *
 * @param[in] client the Aranya Client
 * @param[in] team the team's ID
 * @param[in] addr the peer's Aranya network address
 * @param[in] config configuration values for syncing with a peer.
 *
 * @relates AranyaClient.
 */
AranyaError aranya_add_sync_peer(const struct AranyaClient *client,
                                 const struct AranyaTeamId *team,
                                 AranyaAddr addr,
                                 const struct AranyaSyncPeerConfig *config);

/**
 * Add the peer for automatic periodic Aranya state syncing.
 *
 * If a peer is not reachable on the network, sync errors
 * will appear in the tracing logs and
 * Aranya will be unable to sync state with that peer.
 *
 * @param[in] client the Aranya Client
 * @param[in] team the team's ID
 * @param[in] addr the peer's Aranya network address
 * @param[in] config configuration values for syncing with a peer.
 *
 * @relates AranyaClient.
 */
AranyaError aranya_add_sync_peer_ext(const struct AranyaClient *client,
                                     const struct AranyaTeamId *team,
                                     AranyaAddr addr,
                                     const struct AranyaSyncPeerConfig *config,
                                     struct AranyaExtError *__ext_err);

/**
 * Remove the peer from automatic Aranya state syncing.
 *
 * @param[in] client the Aranya Client
 * @param[in] team the team's ID
 * @param[in] addr the peer's Aranya network address
 *
 * @relates AranyaClient.
 */
AranyaError aranya_remove_sync_peer(const struct AranyaClient *client,
                                    const struct AranyaTeamId *team,
                                    AranyaAddr addr);

/**
 * Remove the peer from automatic Aranya state syncing.
 *
 * @param[in] client the Aranya Client
 * @param[in] team the team's ID
 * @param[in] addr the peer's Aranya network address
 *
 * @relates AranyaClient.
 */
AranyaError aranya_remove_sync_peer_ext(const struct AranyaClient *client,
                                        const struct AranyaTeamId *team,
                                        AranyaAddr addr,
                                        struct AranyaExtError *__ext_err);

#if defined(ENABLE_ARANYA_PREVIEW)
/**
 * Subscribe to hello notifications from a sync peer.
 *
 * This will request the peer to send hello notifications when their graph head changes.
 *
 * @param[in] client the Aranya Client [`AranyaClient`](@ref AranyaClient).
 * @param[in] team the team's ID [`AranyaTeamId`](@ref AranyaTeamId).
 * @param[in] peer the peer's Aranya network address [`AranyaAddr`](@ref AranyaAddr).
 * @param[in] graph_change_delay minimum delay between notifications when graph changes.
 * @param[in] duration how long the subscription should remain active.
 * @param[in] schedule_delay interval for periodic scheduled hello sends.
 *
 * @relates AranyaClient.
 */
AranyaError aranya_sync_hello_subscribe(const struct AranyaClient *client,
                                        const struct AranyaTeamId *team,
                                        AranyaAddr peer,
                                        AranyaDuration graph_change_delay,
                                        AranyaDuration duration,
                                        AranyaDuration schedule_delay);
#endif

#if defined(ENABLE_ARANYA_PREVIEW)
/**
 * Subscribe to hello notifications from a sync peer.
 *
 * This will request the peer to send hello notifications when their graph head changes.
 *
 * @param[in] client the Aranya Client [`AranyaClient`](@ref AranyaClient).
 * @param[in] team the team's ID [`AranyaTeamId`](@ref AranyaTeamId).
 * @param[in] peer the peer's Aranya network address [`AranyaAddr`](@ref AranyaAddr).
 * @param[in] graph_change_delay minimum delay between notifications when graph changes.
 * @param[in] duration how long the subscription should remain active.
 * @param[in] schedule_delay interval for periodic scheduled hello sends.
 *
 * @relates AranyaClient.
 */
AranyaError aranya_sync_hello_subscribe_ext(const struct AranyaClient *client,
                                            const struct AranyaTeamId *team,
                                            AranyaAddr peer,
                                            AranyaDuration graph_change_delay,
                                            AranyaDuration duration,
                                            AranyaDuration schedule_delay,
                                            struct AranyaExtError *__ext_err);
#endif

#if defined(ENABLE_ARANYA_PREVIEW)
/**
 * Unsubscribe from hello notifications from a sync peer.
 *
 * This will stop receiving hello notifications from the specified peer.
 *
 * @param[in] client the Aranya Client [`AranyaClient`](@ref AranyaClient).
 * @param[in] team the team's ID [`AranyaTeamId`](@ref AranyaTeamId).
 * @param[in] addr the peer's Aranya network address [`AranyaAddr`](@ref AranyaAddr).
 *
 * @relates AranyaClient.
 */
AranyaError aranya_sync_hello_unsubscribe(const struct AranyaClient *client,
                                          const struct AranyaTeamId *team,
                                          AranyaAddr peer);
#endif

#if defined(ENABLE_ARANYA_PREVIEW)
/**
 * Unsubscribe from hello notifications from a sync peer.
 *
 * This will stop receiving hello notifications from the specified peer.
 *
 * @param[in] client the Aranya Client [`AranyaClient`](@ref AranyaClient).
 * @param[in] team the team's ID [`AranyaTeamId`](@ref AranyaTeamId).
 * @param[in] addr the peer's Aranya network address [`AranyaAddr`](@ref AranyaAddr).
 *
 * @relates AranyaClient.
 */
AranyaError aranya_sync_hello_unsubscribe_ext(const struct AranyaClient *client,
                                              const struct AranyaTeamId *team,
                                              AranyaAddr peer,
                                              struct AranyaExtError *__ext_err);
#endif

/**
 * Sync with peer immediately.
 *
 * If a peer is not reachable on the network, sync errors
 * will appear in the tracing logs and
 * Aranya will be unable to sync state with that peer.
 *
 *
 * This function ignores [`aranya_sync_peer_config_builder_set_interval`](@ref aranya_sync_peer_config_builder_set_interval) and
 * [`aranya_sync_peer_config_builder_set_sync_later`](@ref aranya_sync_peer_config_builder_set_sync_later), if set.
 *
 * @param[in] client the Aranya Client
 * @param[in] team the team's ID
 * @param[in] addr the peer's Aranya network address
 * @param[in] config configuration values for syncing with a peer.
 *
 * Default values for a sync config will be used if `config` is `NULL`
 *
 * @relates AranyaClient.
 */
AranyaError aranya_sync_now(const struct AranyaClient *client,
                            const struct AranyaTeamId *team,
                            AranyaAddr addr,
                            const struct AranyaSyncPeerConfig *config);

/**
 * Sync with peer immediately.
 *
 * If a peer is not reachable on the network, sync errors
 * will appear in the tracing logs and
 * Aranya will be unable to sync state with that peer.
 *
 *
 * This function ignores [`aranya_sync_peer_config_builder_set_interval`](@ref aranya_sync_peer_config_builder_set_interval) and
 * [`aranya_sync_peer_config_builder_set_sync_later`](@ref aranya_sync_peer_config_builder_set_sync_later), if set.
 *
 * @param[in] client the Aranya Client
 * @param[in] team the team's ID
 * @param[in] addr the peer's Aranya network address
 * @param[in] config configuration values for syncing with a peer.
 *
 * Default values for a sync config will be used if `config` is `NULL`
 *
 * @relates AranyaClient.
 */
AranyaError aranya_sync_now_ext(const struct AranyaClient *client,
                                const struct AranyaTeamId *team,
                                AranyaAddr addr,
                                const struct AranyaSyncPeerConfig *config,
                                struct AranyaExtError *__ext_err);

/**
 * Query devices on team.
 *
 * @param[in] client the Aranya Client
 * @param[in] team the team's ID
 * @param[out] devices returns a list of device IDs on the team
 * @param[in,out] devices_len returns the length of the devices list
 *
 * @relates AranyaClient.
 */
AranyaError aranya_team_devices(const struct AranyaClient *client,
                                const struct AranyaTeamId *team,
                                struct AranyaDeviceId *devices,
                                size_t *devices_len);

/**
 * Query devices on team.
 *
 * @param[in] client the Aranya Client
 * @param[in] team the team's ID
 * @param[out] devices returns a list of device IDs on the team
 * @param[in,out] devices_len returns the length of the devices list
 *
 * @relates AranyaClient.
 */
AranyaError aranya_team_devices_ext(const struct AranyaClient *client,
                                    const struct AranyaTeamId *team,
                                    struct AranyaDeviceId *devices,
                                    size_t *devices_len,
                                    struct AranyaExtError *__ext_err);

/**
 * Returns the role assigned to the device, if any.
 *
 * @param[in] client the Aranya Client
 * @param[in] team the team's ID
 * @param[out] device the ID of the device
 * @param[out] role_out the role assigned to the device. `role_out` will be zeroed
 * if a role was not assigned to the device
 * @param[out] has_role whether a role is assigned to the device
 *
 * @relates AranyaClient.
 */
AranyaError aranya_team_device_role(const struct AranyaClient *client,
                                    const struct AranyaTeamId *team,
                                    const struct AranyaDeviceId *device,
                                    struct AranyaRole *role_out,
                                    bool *has_role);

/**
 * Returns the role assigned to the device, if any.
 *
 * @param[in] client the Aranya Client
 * @param[in] team the team's ID
 * @param[out] device the ID of the device
 * @param[out] role_out the role assigned to the device. `role_out` will be zeroed
 * if a role was not assigned to the device
 * @param[out] has_role whether a role is assigned to the device
 *
 * @relates AranyaClient.
 */
AranyaError aranya_team_device_role_ext(const struct AranyaClient *client,
                                        const struct AranyaTeamId *team,
                                        const struct AranyaDeviceId *device,
                                        struct AranyaRole *role_out,
                                        bool *has_role,
                                        struct AranyaExtError *__ext_err);

/**
 * Query device's keybundle.
 *
 * @param[in] client the Aranya Client
 * @param[in] team the team's ID
 * @param[in] device the device's ID
 * @param[out] keybundle keybundle byte buffer `KeyBundle`.
 * @param[in,out] keybundle_len returns the length of the serialized keybundle.
 *
 * @relates AranyaClient.
 */
AranyaError aranya_team_device_keybundle(const struct AranyaClient *client,
                                         const struct AranyaTeamId *team,
                                         const struct AranyaDeviceId *device,
                                         uint8_t *keybundle,
                                         size_t *keybundle_len);

/**
 * Query device's keybundle.
 *
 * @param[in] client the Aranya Client
 * @param[in] team the team's ID
 * @param[in] device the device's ID
 * @param[out] keybundle keybundle byte buffer `KeyBundle`.
 * @param[in,out] keybundle_len returns the length of the serialized keybundle.
 *
 * @relates AranyaClient.
 */
AranyaError aranya_team_device_keybundle_ext(const struct AranyaClient *client,
                                             const struct AranyaTeamId *team,
                                             const struct AranyaDeviceId *device,
                                             uint8_t *keybundle,
                                             size_t *keybundle_len,
                                             struct AranyaExtError *__ext_err);

/**
 * Query device label assignments.
 *
 * Returns an `AranyaBufferTooSmall` error if the output buffer is too small to hold the labels.
 * Writes the number of labels that would have been returned to `labels_len`.
 * The application can use `labels_len` to allocate a larger buffer.
 *
 * @param[in] client the Aranya Client
 * @param[in] team the team's ID
 * @param[in] device the device's ID
 * @param[out] labels returns a list of labels assigned to the device
 * @param[in,out] labels_len returns the length of the labels list
 *
 * @relates AranyaClient.
 */
AranyaError aranya_team_device_label_assignments(const struct AranyaClient *client,
                                                 const struct AranyaTeamId *team,
                                                 const struct AranyaDeviceId *device,
                                                 struct AranyaLabelId *labels,
                                                 size_t *labels_len);

/**
 * Query device label assignments.
 *
 * Returns an `AranyaBufferTooSmall` error if the output buffer is too small to hold the labels.
 * Writes the number of labels that would have been returned to `labels_len`.
 * The application can use `labels_len` to allocate a larger buffer.
 *
 * @param[in] client the Aranya Client
 * @param[in] team the team's ID
 * @param[in] device the device's ID
 * @param[out] labels returns a list of labels assigned to the device
 * @param[in,out] labels_len returns the length of the labels list
 *
 * @relates AranyaClient.
 */
AranyaError aranya_team_device_label_assignments_ext(const struct AranyaClient *client,
                                                     const struct AranyaTeamId *team,
                                                     const struct AranyaDeviceId *device,
                                                     struct AranyaLabelId *labels,
                                                     size_t *labels_len,
                                                     struct AranyaExtError *__ext_err);

/**
 * Query for list of existing labels.
 *
 * Returns an `AranyaBufferTooSmall` error if the output buffer is too small to hold the labels.
 * Writes the number of labels that would have been returned to `labels_len`.
 * The application can use `labels_len` to allocate a larger buffer.
 *
 * @param[in] client the Aranya Client
 * @param[in] team the team's ID
 * @param[out] labels returns a list of labels
 * @param[in,out] labels_len returns the length of the labels list
 *
 * @relates AranyaClient.
 */
AranyaError aranya_team_labels(const struct AranyaClient *client,
                               const struct AranyaTeamId *team,
                               struct AranyaLabelId *labels,
                               size_t *labels_len);

/**
 * Query for list of existing labels.
 *
 * Returns an `AranyaBufferTooSmall` error if the output buffer is too small to hold the labels.
 * Writes the number of labels that would have been returned to `labels_len`.
 * The application can use `labels_len` to allocate a larger buffer.
 *
 * @param[in] client the Aranya Client
 * @param[in] team the team's ID
 * @param[out] labels returns a list of labels
 * @param[in,out] labels_len returns the length of the labels list
 *
 * @relates AranyaClient.
 */
AranyaError aranya_team_labels_ext(const struct AranyaClient *client,
                                   const struct AranyaTeamId *team,
                                   struct AranyaLabelId *labels,
                                   size_t *labels_len,
                                   struct AranyaExtError *__ext_err);

/**
 * Query if a label exists.
 *
 * @param[in] client the Aranya Client
 * @param[in] team the team's ID
 * @param[in] device the device's ID
 * @param[in] label the label
 * @param[out] __output boolean indicating whether the label exists.
 *
 * @relates AranyaClient.
 */
AranyaError aranya_team_label_exists(const struct AranyaClient *client,
                                     const struct AranyaTeamId *team,
                                     const struct AranyaLabelId *label,
                                     bool *__output);

/**
 * Query if a label exists.
 *
 * @param[in] client the Aranya Client
 * @param[in] team the team's ID
 * @param[in] device the device's ID
 * @param[in] label the label
 * @param[out] __output boolean indicating whether the label exists.
 *
 * @relates AranyaClient.
 */
AranyaError aranya_team_label_exists_ext(const struct AranyaClient *client,
                                         const struct AranyaTeamId *team,
                                         const struct AranyaLabelId *label,
                                         bool *__output,
                                         struct AranyaExtError *__ext_err);

#if defined(ENABLE_ARANYA_AFC)
/**
 * Releases any resources associated with `ptr`.
 *
 * `ptr` must either be null or initialized by `::aranya_afc_send_channel_init`.
 *
 * @relates AranyaAfcSendChannel
 */
AranyaError aranya_afc_send_channel_cleanup(struct AranyaAfcSendChannel *ptr);
#endif

#if defined(ENABLE_ARANYA_AFC)
/**
 * Releases any resources associated with `ptr`.
 *
 * `ptr` must either be null or initialized by `::aranya_afc_receive_channel_init`.
 *
 * @relates AranyaAfcReceiveChannel
 */
AranyaError aranya_afc_receive_channel_cleanup(struct AranyaAfcReceiveChannel *ptr);
#endif

#if defined(ENABLE_ARANYA_AFC)
/**
 * Releases any resources associated with `ptr`.
 *
 * `ptr` must either be null or initialized by `::aranya_afc_ctrl_msg_init`.
 *
 * @relates AranyaAfcCtrlMsg
 */
AranyaError aranya_afc_ctrl_msg_cleanup(struct AranyaAfcCtrlMsg *ptr);
#endif

#if defined(ENABLE_ARANYA_AFC)
/**
 * Releases any resources associated with `ptr`.
 *
 * `ptr` must either be null or initialized by `::aranya_afc_seq_init`.
 *
 * @relates AranyaAfcSeq
 */
AranyaError aranya_afc_seq_cleanup(struct AranyaAfcSeq *ptr);
#endif

#if defined(ENABLE_ARANYA_AFC)
/**
 * Create a send-only AFC channel between this device and a peer.
 *
 * Note that the control message needs to be sent to the other peer using the
 * transport of your choice to create the other side of the channel.
 *
 * Permission to perform this operation is checked against the Aranya policy.
 * Both the current node and its peer should have permission to use the label
 * and have appropriate channel permissions.
 *
 * @param[in]  client the Aranya Client
 * @param[in]  team_id the team's identifier
 * @param[in]  peer_id the peer's identifier
 * @param[in]  label_id the label identifier  to create the channel with.
 * @param[out] channel the AFC channel object
 * @param[out] control the AFC control message
 *
 * @relates AranyaClient.
 */
AranyaError aranya_afc_create_channel(const struct AranyaClient *client,
                                      const struct AranyaTeamId *team_id,
                                      const struct AranyaDeviceId *peer_id,
                                      const struct AranyaLabelId *label_id,
                                      struct AranyaAfcSendChannel *channel,
                                      struct AranyaAfcCtrlMsg *control);
#endif

#if defined(ENABLE_ARANYA_AFC)
/**
 * Create a send-only AFC channel between this device and a peer.
 *
 * Note that the control message needs to be sent to the other peer using the
 * transport of your choice to create the other side of the channel.
 *
 * Permission to perform this operation is checked against the Aranya policy.
 * Both the current node and its peer should have permission to use the label
 * and have appropriate channel permissions.
 *
 * @param[in]  client the Aranya Client
 * @param[in]  team_id the team's identifier
 * @param[in]  peer_id the peer's identifier
 * @param[in]  label_id the label identifier  to create the channel with.
 * @param[out] channel the AFC channel object
 * @param[out] control the AFC control message
 *
 * @relates AranyaClient.
 */
AranyaError aranya_afc_create_channel_ext(const struct AranyaClient *client,
                                          const struct AranyaTeamId *team_id,
                                          const struct AranyaDeviceId *peer_id,
                                          const struct AranyaLabelId *label_id,
                                          struct AranyaAfcSendChannel *channel,
                                          struct AranyaAfcCtrlMsg *control,
                                          struct AranyaExtError *__ext_err);
#endif

#if defined(ENABLE_ARANYA_AFC)
/**
 * Accept a receive-only AFC channel from by a peer by processing a control message.
 *
 * @param[in]  client the Aranya Client
 * @param[in]  team_id the team's identifier
 * @param[in]  control the AFC control message.
 * @param[out] channel the AFC channel object
 * @param[out] __output the corresponding AFC channel type
 *
 * @relates AranyaClient.
 */
AranyaError aranya_afc_accept_channel(const struct AranyaClient *client,
                                      const struct AranyaTeamId *team_id,
                                      const uint8_t *control,
                                      size_t control_len,
                                      struct AranyaAfcReceiveChannel *channel);
#endif

#if defined(ENABLE_ARANYA_AFC)
/**
 * Accept a receive-only AFC channel from by a peer by processing a control message.
 *
 * @param[in]  client the Aranya Client
 * @param[in]  team_id the team's identifier
 * @param[in]  control the AFC control message.
 * @param[out] channel the AFC channel object
 * @param[out] __output the corresponding AFC channel type
 *
 * @relates AranyaClient.
 */
AranyaError aranya_afc_accept_channel_ext(const struct AranyaClient *client,
                                          const struct AranyaTeamId *team_id,
                                          const uint8_t *control,
                                          size_t control_len,
                                          struct AranyaAfcReceiveChannel *channel,
                                          struct AranyaExtError *__ext_err);
#endif

#if defined(ENABLE_ARANYA_AFC)
/**
 * Returns the [`AranyaLabelId`](@ref AranyaLabelId) for the associated [`AranyaAfcSendChannel`](@ref AranyaAfcSendChannel).
 *
 * @param[in]  channel the AFC channel object
 * @param[out] __output the corresponding label ID
 */
AranyaError aranya_afc_send_channel_get_label_id(const struct AranyaAfcSendChannel *channel,
                                                 struct AranyaLabelId *__output);
#endif

#if defined(ENABLE_ARANYA_AFC)
/**
 * Returns the [`AranyaLabelId`](@ref AranyaLabelId) for the associated [`AranyaAfcSendChannel`](@ref AranyaAfcSendChannel).
 *
 * @param[in]  channel the AFC channel object
 * @param[out] __output the corresponding label ID
 */
AranyaError aranya_afc_send_channel_get_label_id_ext(const struct AranyaAfcSendChannel *channel,
                                                     struct AranyaLabelId *__output,
                                                     struct AranyaExtError *__ext_err);
#endif

#if defined(ENABLE_ARANYA_AFC)
/**
 * Returns the [`AranyaAfcChannelId`](@ref AranyaAfcChannelId) for the associated [`AranyaAfcSendChannel`](@ref AranyaAfcSendChannel).
 *
 * @param[in]  channel the AFC channel object
 * @param[out] __output the corresponding channel ID
 */
AranyaError aranya_afc_send_channel_get_id(const struct AranyaAfcSendChannel *channel,
                                           struct AranyaAfcChannelId *__output);
#endif

#if defined(ENABLE_ARANYA_AFC)
/**
 * Returns the [`AranyaAfcChannelId`](@ref AranyaAfcChannelId) for the associated [`AranyaAfcSendChannel`](@ref AranyaAfcSendChannel).
 *
 * @param[in]  channel the AFC channel object
 * @param[out] __output the corresponding channel ID
 */
AranyaError aranya_afc_send_channel_get_id_ext(const struct AranyaAfcSendChannel *channel,
                                               struct AranyaAfcChannelId *__output,
                                               struct AranyaExtError *__ext_err);
#endif

#if defined(ENABLE_ARANYA_AFC)
/**
 * Returns the device ID of the peer on the other side of the channel.
 *
 * @param[in]  channel the AFC channel object.
 * @param[out] __output the peer's ID.
 */
AranyaError aranya_afc_send_channel_get_peer_id(const struct AranyaAfcSendChannel *channel,
                                                struct AranyaDeviceId *__output);
#endif

#if defined(ENABLE_ARANYA_AFC)
/**
 * Returns the device ID of the peer on the other side of the channel.
 *
 * @param[in]  channel the AFC channel object.
 * @param[out] __output the peer's ID.
 */
AranyaError aranya_afc_send_channel_get_peer_id_ext(const struct AranyaAfcSendChannel *channel,
                                                    struct AranyaDeviceId *__output,
                                                    struct AranyaExtError *__ext_err);
#endif

#if defined(ENABLE_ARANYA_AFC)
/**
 * Returns the [`AranyaLabelId`](@ref AranyaLabelId) for the associated [`AranyaAfcReceiveChannel`](@ref AranyaAfcReceiveChannel).
 *
 * @param[in]  channel the AFC channel object
 * @param[out] __output the corresponding label ID
 */
AranyaError aranya_afc_receive_channel_get_label_id(const struct AranyaAfcReceiveChannel *channel,
                                                    struct AranyaLabelId *__output);
#endif

#if defined(ENABLE_ARANYA_AFC)
/**
 * Returns the [`AranyaLabelId`](@ref AranyaLabelId) for the associated [`AranyaAfcReceiveChannel`](@ref AranyaAfcReceiveChannel).
 *
 * @param[in]  channel the AFC channel object
 * @param[out] __output the corresponding label ID
 */
AranyaError aranya_afc_receive_channel_get_label_id_ext(const struct AranyaAfcReceiveChannel *channel,
                                                        struct AranyaLabelId *__output,
                                                        struct AranyaExtError *__ext_err);
#endif

#if defined(ENABLE_ARANYA_AFC)
/**
 * Returns the [`AranyaAfcChannelId`](@ref AranyaAfcChannelId) for the associated [`AranyaAfcReceiveChannel`](@ref AranyaAfcReceiveChannel).
 *
 * @param[in]  channel the AFC channel object
 * @param[out] __output the corresponding channel ID
 */
AranyaError aranya_afc_receive_channel_get_id(const struct AranyaAfcReceiveChannel *channel,
                                              struct AranyaAfcChannelId *__output);
#endif

#if defined(ENABLE_ARANYA_AFC)
/**
 * Returns the [`AranyaAfcChannelId`](@ref AranyaAfcChannelId) for the associated [`AranyaAfcReceiveChannel`](@ref AranyaAfcReceiveChannel).
 *
 * @param[in]  channel the AFC channel object
 * @param[out] __output the corresponding channel ID
 */
AranyaError aranya_afc_receive_channel_get_id_ext(const struct AranyaAfcReceiveChannel *channel,
                                                  struct AranyaAfcChannelId *__output,
                                                  struct AranyaExtError *__ext_err);
#endif

#if defined(ENABLE_ARANYA_AFC)
/**
 * Returns the device ID of the peer on the other side of the channel.
 *
 * @param[in]  channel the AFC channel object.
 * @param[out] __output the peer's ID.
 */
AranyaError aranya_afc_receive_channel_get_peer_id(const struct AranyaAfcReceiveChannel *channel,
                                                   struct AranyaDeviceId *__output);
#endif

#if defined(ENABLE_ARANYA_AFC)
/**
 * Returns the device ID of the peer on the other side of the channel.
 *
 * @param[in]  channel the AFC channel object.
 * @param[out] __output the peer's ID.
 */
AranyaError aranya_afc_receive_channel_get_peer_id_ext(const struct AranyaAfcReceiveChannel *channel,
                                                       struct AranyaDeviceId *__output,
                                                       struct AranyaExtError *__ext_err);
#endif

#if defined(ENABLE_ARANYA_AFC)
/**
 * Returns the raw data for a given [`AranyaAfcCtrlMsg`](@ref AranyaAfcCtrlMsg).
 *
 * Note that the lifetime of the pointer is tied to the [`AranyaAfcCtrlMsg`](@ref AranyaAfcCtrlMsg).
 *
 * @param[in]  control the control message produced by creating a channel.
 * @param[out] ptr the raw pointer of the stored buffer.
 * @param[out] len the raw length of the stored buffer.
 */
AranyaError aranya_afc_ctrl_msg_get_bytes(const struct AranyaAfcCtrlMsg *control,
                                          const uint8_t **ptr,
                                          size_t *len);
#endif

#if defined(ENABLE_ARANYA_AFC)
/**
 * Returns the raw data for a given [`AranyaAfcCtrlMsg`](@ref AranyaAfcCtrlMsg).
 *
 * Note that the lifetime of the pointer is tied to the [`AranyaAfcCtrlMsg`](@ref AranyaAfcCtrlMsg).
 *
 * @param[in]  control the control message produced by creating a channel.
 * @param[out] ptr the raw pointer of the stored buffer.
 * @param[out] len the raw length of the stored buffer.
 */
AranyaError aranya_afc_ctrl_msg_get_bytes_ext(const struct AranyaAfcCtrlMsg *control,
                                              const uint8_t **ptr,
                                              size_t *len,
                                              struct AranyaExtError *__ext_err);
#endif

#if defined(ENABLE_ARANYA_AFC)
/**
 * Returns the three-way comparison between `seq1` and `seq2`.
 *
 * @param[in]  seq1 the first sequence number to compare.
 * @param[in]  seq1 the second sequence number to compare.
 * @param[out] __output the comparison result (-1 is <, 0 is =, 1 is >).
 */
AranyaError aranya_afc_seq_cmp(const struct AranyaAfcSeq *seq1,
                               const struct AranyaAfcSeq *seq2,
                               int *__output);
#endif

#if defined(ENABLE_ARANYA_AFC)
/**
 * Returns the three-way comparison between `seq1` and `seq2`.
 *
 * @param[in]  seq1 the first sequence number to compare.
 * @param[in]  seq1 the second sequence number to compare.
 * @param[out] __output the comparison result (-1 is <, 0 is =, 1 is >).
 */
AranyaError aranya_afc_seq_cmp_ext(const struct AranyaAfcSeq *seq1,
                                   const struct AranyaAfcSeq *seq2,
                                   int *__output,
                                   struct AranyaExtError *__ext_err);
#endif

#if defined(ENABLE_ARANYA_AFC)
/**
 * Encrypts and authenticates `plaintext`, and writes it to `dst`.
 *
 * Note that `dst` must be at least `plaintext.len()` + `aranya_afc_channel_overhead()`,
 * or the function will return an error (`InvalidArgument` or `BufferTooSmall`).
 *
 * @param[in]  channel the AFC channel object
 * @param[in]  plaintext the message being encrypted.
 * @param[out] dst the output buffer the ciphertext is written to.
 */
AranyaError aranya_afc_channel_seal(struct AranyaAfcSendChannel *channel,
                                    const uint8_t *plaintext,
                                    size_t plaintext_len,
                                    uint8_t *dst,
                                    size_t *dst_len);
#endif

#if defined(ENABLE_ARANYA_AFC)
/**
 * Encrypts and authenticates `plaintext`, and writes it to `dst`.
 *
 * Note that `dst` must be at least `plaintext.len()` + `aranya_afc_channel_overhead()`,
 * or the function will return an error (`InvalidArgument` or `BufferTooSmall`).
 *
 * @param[in]  channel the AFC channel object
 * @param[in]  plaintext the message being encrypted.
 * @param[out] dst the output buffer the ciphertext is written to.
 */
AranyaError aranya_afc_channel_seal_ext(struct AranyaAfcSendChannel *channel,
                                        const uint8_t *plaintext,
                                        size_t plaintext_len,
                                        uint8_t *dst,
                                        size_t *dst_len,
                                        struct AranyaExtError *__ext_err);
#endif

#if defined(ENABLE_ARANYA_AFC)
/**
 * Decrypts and authenticates `ciphertext`, and writes it to `dst`.
 *
 * Note that `dst` must be at least `ciphertext.len()` - `aranya_afc_channel_overhead()`,
 * or the function will return an error (`InvalidArgument` or `BufferTooSmall`).
 *
 * @param[in]  channel the AFC channel object
 * @param[in]  ciphertext the message being decrypted.
 * @param[out] dst the output buffer the message is written to.
 * @param[out] seq the sequence number for the opened message, for reordering.
 */
AranyaError aranya_afc_channel_open(const struct AranyaAfcReceiveChannel *channel,
                                    const uint8_t *ciphertext,
                                    size_t ciphertext_len,
                                    uint8_t *dst,
                                    size_t *dst_len,
                                    struct AranyaAfcSeq *seq);
#endif

#if defined(ENABLE_ARANYA_AFC)
/**
 * Decrypts and authenticates `ciphertext`, and writes it to `dst`.
 *
 * Note that `dst` must be at least `ciphertext.len()` - `aranya_afc_channel_overhead()`,
 * or the function will return an error (`InvalidArgument` or `BufferTooSmall`).
 *
 * @param[in]  channel the AFC channel object
 * @param[in]  ciphertext the message being decrypted.
 * @param[out] dst the output buffer the message is written to.
 * @param[out] seq the sequence number for the opened message, for reordering.
 */
AranyaError aranya_afc_channel_open_ext(const struct AranyaAfcReceiveChannel *channel,
                                        const uint8_t *ciphertext,
                                        size_t ciphertext_len,
                                        uint8_t *dst,
                                        size_t *dst_len,
                                        struct AranyaAfcSeq *seq,
                                        struct AranyaExtError *__ext_err);
#endif

#if defined(ENABLE_ARANYA_AFC)
/**
 * Removes an [`AranyaAfcSendChannel`](@ref AranyaAfcSendChannel) from use.
 *
 * Note that this function takes ownership of the [`AranyaAfcSendChannel`](@ref AranyaAfcSendChannel) and invalidates
 * any further use (i.e. calling seal).
 *
 * @param[in]  client the Aranya Client
 * @param[in]  channel the AFC channel object
 *
 * @relates AranyaClient.
 */
AranyaError aranya_afc_send_channel_delete(const struct AranyaClient *client,
                                           struct AranyaAfcSendChannel *channel);
#endif

#if defined(ENABLE_ARANYA_AFC)
/**
 * Removes an [`AranyaAfcSendChannel`](@ref AranyaAfcSendChannel) from use.
 *
 * Note that this function takes ownership of the [`AranyaAfcSendChannel`](@ref AranyaAfcSendChannel) and invalidates
 * any further use (i.e. calling seal).
 *
 * @param[in]  client the Aranya Client
 * @param[in]  channel the AFC channel object
 *
 * @relates AranyaClient.
 */
AranyaError aranya_afc_send_channel_delete_ext(const struct AranyaClient *client,
                                               struct AranyaAfcSendChannel *channel,
                                               struct AranyaExtError *__ext_err);
#endif

#if defined(ENABLE_ARANYA_AFC)
/**
 * Removes an [`AranyaAfcReceiveChannel`](@ref AranyaAfcReceiveChannel) from use.
 *
 * Note that this function takes ownership of the [`AranyaAfcReceiveChannel`](@ref AranyaAfcReceiveChannel) and invalidates
 * any further use (i.e. calling seal).
 *
 * @param[in]  client the Aranya Client
 * @param[in]  channel the AFC channel object
 *
 * @relates AranyaClient.
 */
AranyaError aranya_afc_receive_channel_delete(const struct AranyaClient *client,
                                              struct AranyaAfcReceiveChannel *channel);
#endif

#if defined(ENABLE_ARANYA_AFC)
/**
 * Removes an [`AranyaAfcReceiveChannel`](@ref AranyaAfcReceiveChannel) from use.
 *
 * Note that this function takes ownership of the [`AranyaAfcReceiveChannel`](@ref AranyaAfcReceiveChannel) and invalidates
 * any further use (i.e. calling seal).
 *
 * @param[in]  client the Aranya Client
 * @param[in]  channel the AFC channel object
 *
 * @relates AranyaClient.
 */
AranyaError aranya_afc_receive_channel_delete_ext(const struct AranyaClient *client,
                                                  struct AranyaAfcReceiveChannel *channel,
                                                  struct AranyaExtError *__ext_err);
#endif

#ifdef __cplusplus
}  // extern "C"
#endif  // __cplusplus

#endif  /* ARANYA_CLIENT_H */


