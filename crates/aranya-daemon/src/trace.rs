//! Distributed tracing context utilities.
//!
//! This module provides helpers for extracting and propagating RPC trace IDs
//! from tarpc context throughout the daemon's execution.

pub use tarpc::trace::TraceId;
use tracing::Span;

tokio::task_local! {
    #[doc(hidden)]
    pub static TRACE_CONTEXT: Option<TraceId>;
}

/// Extracts the trace ID from a tarpc context.
///
/// The trace ID is generated by the client and included in the request.
/// If no trace ID is found in the context, a new one is generated.
///
/// # Example
///
/// ```rust,ignore
/// use tarpc::context;
/// use aranya_daemon::trace::extract_trace_id;
///
/// let ctx = context::current();
/// let trace_id = extract_trace_id(&ctx).to_string();
/// ```
pub fn extract_trace_id(ctx: &tarpc::context::Context) -> TraceId {
    ctx.trace_context.trace_id
}

/// Returns the current trace ID if one is set in async-local storage.
pub fn current_trace_id() -> Option<TraceId> {
    TRACE_CONTEXT.try_with(|t| t.clone()).ok().flatten()
}

/// Sets the trace context for the duration of the provided future.
///
/// This ensures the trace ID is available to all tasks spawned within.
///
pub async fn with_trace_context<F>(trace_id: TraceId, fut: F) -> <F as std::future::Future>::Output
where
    F: std::future::Future,
{
    TRACE_CONTEXT.scope(Some(trace_id), fut).await
}

/// Adds the trace ID to a span's attributes if available.
///
/// This is typically called when creating a new span to ensure trace ID
/// is included in all log output.
///
pub fn add_trace_to_span(span: &Span) {
    if let Some(trace_id) = current_trace_id() {
        span.record("trace_id", &tracing::field::display(trace_id));
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    async fn test_trace_id_creation() {
        let trace_id = TraceId::default();
        assert!(!trace_id.to_string().is_empty());
    }

    #[tokio::test]
    async fn test_trace_context_propagation() {
        let trace_id = TraceId::default();

        with_trace_context(trace_id.clone(), async {
            assert_eq!(current_trace_id(), Some(trace_id));
        })
        .await;

        assert_eq!(current_trace_id(), None);
    }

    #[tokio::test]
    async fn test_extract_trace_id() {
        let ctx = tarpc::context::current();
        let trace_id = extract_trace_id(&ctx);
        assert!(!trace_id.to_string().is_empty());
    }
}
