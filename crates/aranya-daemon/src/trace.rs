//! Distributed tracing context utilities.
//!
//! This module provides helpers for extracting and propagating RPC trace IDs
//! from tarpc context throughout the daemon's execution.

use std::sync::Arc;
use tracing::Span;

/// A unique identifier for correlating RPC requests across the system.
///
/// This trace ID is extracted from tarpc's context and propagated through
/// all log spans and effects to enable end-to-end request tracing.
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TraceId(Arc<str>);

impl TraceId {
    /// Creates a new `TraceId` from a string.
    pub fn new(id: impl Into<String>) -> Self {
        Self(Arc::from(id.into()))
    }

    /// Returns the trace ID as a string slice.
    pub fn as_str(&self) -> &str {
        &self.0
    }
}

impl std::fmt::Display for TraceId {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        self.0.fmt(f)
    }
}

impl From<&str> for TraceId {
    fn from(s: &str) -> Self {
        Self::new(s.to_string())
    }
}

impl From<String> for TraceId {
    fn from(s: String) -> Self {
        Self::new(s)
    }
}

tokio::task_local! {
    #[doc(hidden)]
    pub static TRACE_CONTEXT: Option<TraceId>;
}

/// Extracts the trace ID from a tarpc context.
///
/// The trace ID is generated by the client and included in the request.
/// If no trace ID is found in the context, a new one is generated.
///
/// # Example
///
/// ```rust,ignore
/// use tarpc::context;
/// use aranya_daemon::trace::extract_trace_id;
///
/// let ctx = context::current();
/// let trace_id = extract_trace_id(&ctx).to_string();
/// ```
pub fn extract_trace_id(ctx: &tarpc::context::Context) -> TraceId {
    // Try to extract trace ID from context metadata if available
    // For now, generate one from deadline/unique identifier
    let trace_id = format!("{:?}-{:?}", ctx.deadline, std::process::id());
    TraceId::new(trace_id)
}

/// Returns the current trace ID if one is set in async-local storage.
pub fn current_trace_id() -> Option<TraceId> {
    TRACE_CONTEXT.try_with(|t| t.clone()).ok().flatten()
}

/// Sets the trace context for the duration of the provided future.
///
/// This ensures the trace ID is available to all tasks spawned within.
///
pub async fn with_trace_context<F>(trace_id: TraceId, fut: F) -> <F as std::future::Future>::Output
where
    F: std::future::Future,
{
    TRACE_CONTEXT.scope(Some(trace_id), fut).await
}

/// Adds the trace ID to a span's attributes if available.
///
/// This is typically called when creating a new span to ensure trace ID
/// is included in all log output.
///
pub fn add_trace_to_span(span: &Span) {
    if let Some(trace_id) = current_trace_id() {
        span.record("trace_id", trace_id.as_str());
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    async fn test_trace_id_creation() {
        let trace_id = TraceId::new("test-123");
        assert_eq!(trace_id.as_str(), "test-123");
    }

    #[tokio::test]
    async fn test_trace_context_propagation() {
        let trace_id = TraceId::new("test-456");

        with_trace_context(trace_id.clone(), async {
            assert_eq!(current_trace_id(), Some(trace_id));
        })
        .await;

        assert_eq!(current_trace_id(), None);
    }

    #[tokio::test]
    async fn test_extract_trace_id() {
        let ctx = tarpc::context::current();
        let trace_id = extract_trace_id(&ctx);
        assert!(!trace_id.as_str().is_empty());
    }
}
